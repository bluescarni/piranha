/***************************************************************************
 *   Copyright (C) 2009-2011 by Francesco Biscani                          *
 *   bluescarni@gmail.com                                                  *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifndef PIRANHA_INTEGER_HPP
#define PIRANHA_INTEGER_HPP

#include <algorithm>
#include <boost/integer_traits.hpp>
#include <boost/lexical_cast.hpp>
#include <iostream>
#include <memory>
#include <stdexcept>
#include <string>
#include <type_traits>

#include "config.hpp"
#include "detail/integer_fwd.hpp"
#include "exceptions.hpp"
#include "extended_integer_types.hpp"
#include "math.hpp"
#include "mp_integer.hpp"
#include "type_traits.hpp"

namespace piranha
{

/// General-purpose integer class.
/**
 * This class, similarly to piranha::mp_integer, represents integer numbers of arbitrary size. The difference with
 * piranha::mp_integer is that this class stores small numbers as standard C++ integers,
 * thus avoiding runtime memory allocation. Additionally, arithmetics on small operands will avoid calling the GMP routines.
 * 
 * Whenever the size of the integer exceeds the range of the C++ integer type, the class will automatically switch
 * the internal representation of the number to piranha::mp_integer.
 * 
 * \section interop Interoperability with other types
 * 
 * The class is fully interoperable with the standard C++ types with which piranha::mp_integer is interoperable.
 * Every function interacting with floating-point types will check that the floating-point values are not
 * non-finite: in case of infinities or NaNs, an <tt>std::invalid_argument</tt> exception will be thrown.
 * 
 * \section exception_safety Exception safety guarantee
 * 
 * This class provides the strong exception safety guarantee for all operations. In case of memory allocation errors by GMP routines,
 * the program will terminate.
 * 
 * \section move_semantics Move semantics
 * 
 * Move construction and move assignment will leave the moved-from object in a state that is destructible and assignable.
 * 
 * @author Francesco Biscani (bluescarni@gmail.com)
 */
class integer
{
	public:
		// NOTE: here we have the following guarantees on these types:
		// - int_type is a standard integral type,
		// - wide_int_type is large enough to hold the result of addition, subtraction,
		//   multiplication, division and multadd between instances if int_type.
		/// Immediate integer type.
		/**
		 * Alias for the standard C++ signed integer type used to store small values.
		 */
		typedef @PIRANHA_IMMEDIATE_INTEGER_TYPE@ int_type;
	private:
		typedef @PIRANHA_WIDE_INTEGER_TYPE@ wide_int_type;
		// Paranoia checks.
		static_assert(std::is_pod<int_type>::value && std::is_integral<int_type>::value,"Invalid integer type.");
		typedef std::unique_ptr<mp_integer> ptr_type;
		// Storage definition: enough space and alignment to accomodate both types.
		typedef std::aligned_storage<
			(sizeof(int_type) > sizeof(ptr_type)) ? sizeof(int_type) : sizeof(ptr_type),
			(alignof(int_type) > alignof(ptr_type)) ? alignof(int_type) : alignof(ptr_type)
			>::type storage_type;
		// Getter methods to fetch references to the two types.
		template <typename T>
		T &get()
		{
			piranha_assert((std::is_same<T,int_type>::value && !get_flag()) ||
				(std::is_same<T,ptr_type>::value && get_flag()));
			return *static_cast<T *>(static_cast<void *>(&m_storage));
		}
		template <typename T>
		const T &get() const
		{
			piranha_assert((std::is_same<T,int_type>::value && !get_flag()) ||
				(std::is_same<T,ptr_type>::value && get_flag()));
			return *static_cast<const T *>(static_cast<const void *>(&m_storage));
		}
		// Get/set the flag that tells if the instance is multiprecision (true) or not (false).
		bool get_flag() const
		{
			return m_flag;
		}
		void set_flag(bool flag)
		{
			m_flag = flag;
		}
		// Destructor method.
		void destroy()
		{
			if (unlikely(get_flag())) {
				// Call the destructor of the smart pointer.
				get<ptr_type>().~ptr_type();
			}
		}
		// Promote immediate integer to mp, copying the value.
		void promote()
		{
			piranha_assert(!get_flag());
			auto new_ptr = ::new mp_integer(get<int_type>());
			// No need to destroy int_type, as it is guaranteed to be a POD.
			set_flag(true);
			::new (static_cast<void *>(&m_storage)) ptr_type(new_ptr);
		}
		// Check if a wide int fits in an int_type.
		static bool fits_int_type(const wide_int_type &wn)
		{
			return (wn <= boost::integer_traits<int_type>::const_max && wn >= boost::integer_traits<int_type>::const_min);
		}
		// Basic arithmetic operations for use in operators.
		struct plus
		{
			template <typename T, typename U>
			void operator()(T &a, U &&b) const
			{
				a += std::forward<U>(b);
			}
		};
		struct minus
		{
			template <typename T, typename U>
			void operator()(T &a, U &&b) const
			{
				a -= std::forward<U>(b);
			}
		};
		struct times
		{
			template <typename T, typename U>
			void operator()(T &a, U &&b) const
			{
				a *= std::forward<U>(b);
			}
		};
		struct divide
		{
			template <typename T, typename U>
			void operator()(T &a, U &&b) const
			{
				a /= std::forward<U>(b);
			}
		};
		struct modulo
		{
			template <typename T, typename U>
			void operator()(T &a, U &&b) const
			{
				a %= std::forward<U>(b);
			}
		};
		// Helper to decide whether to move or not input parameter based on the characteristics
		// of another type. It is used in generic_in_place() to move conditionally the mp integer
		// in the second operand if the operand is itself movable.
		template <typename T, typename U>
		static auto conditional_move(U &&value, typename std::enable_if<
			is_nonconst_rvalue_ref<T>::value>::type * = piranha_nullptr) -> decltype(std::move(value))
		{
			return std::move(value);
		}
		template <typename T, typename U>
		static auto conditional_move(U &&value, typename std::enable_if<
			!is_nonconst_rvalue_ref<T>::value>::type * = piranha_nullptr) -> decltype(std::forward<U>(value))
		{
			return std::forward<U>(value);
		}
		// In-place binary operations.
		// Integer operand.
		template <typename Operation, typename Operand>
		integer &in_place(Operation &&op, Operand &&other, typename std::enable_if<
			std::is_same<integer,typename std::decay<Operand>::type>::value>::type * = piranha_nullptr)
		{
			const int f1 = get_flag(), f2 = other.get_flag();
			if (likely(f1 + f2 == 0)) {
				wide_int_type result = get<int_type>();
				op(result,other.get<int_type>());
				if (likely(fits_int_type(result))) {
					get<int_type>() = static_cast<int_type>(result);
					return *this;
				}
			}
			if (!f1) {
				promote();
			}
			if (f2) {
				// Move the mp_integer inside other if other itself can be moved.
				op(*get<ptr_type>(),conditional_move<Operand &&>(*other.get<ptr_type>()));
			} else {
				op(*get<ptr_type>(),other.get<int_type>());
			}
			return *this;
		}
		// Integral operand.
		template <typename Operation, typename Operand>
		integer &in_place(Operation &&op, Operand &&other, typename std::enable_if<
			std::is_integral<typename std::decay<Operand>::type>::value>::type * = piranha_nullptr)
		{
			return in_place(std::forward<Operation>(op),integer(std::forward<Operand>(other)));
		}
		// Floating-point operand.
		template <typename Operation, typename Operand>
		integer &in_place(Operation &&op, Operand &&other, typename std::enable_if<
			std::is_floating_point<typename std::decay<Operand>::type>::value>::type * = piranha_nullptr)
		{
			auto tmp = static_cast<typename std::decay<Operand>::type>(*this);
			op(tmp,std::forward<Operand>(other));
			*this = tmp;
			return *this;
		}
		// Binary operations.
		// Type trait for allowed arguments in arithmetic binary operations.
		template <typename T, typename U>
		struct are_binary_op_types: std::integral_constant<bool,
			(std::is_same<typename std::decay<T>::type,integer>::value && mp_integer::is_interop_type<typename std::decay<U>::type>::value) ||
			(std::is_same<typename std::decay<U>::type,integer>::value && mp_integer::is_interop_type<typename std::decay<T>::type>::value) ||
			(std::is_same<typename std::decay<T>::type,integer>::value && std::is_same<typename std::decay<U>::type,integer>::value)>
		{};
		// Metaprogramming to establish the return type of binary arithmetic operations involving integers.
		// Default result type will be integer itself; for consistency with C/C++ when one of the arguments
		// is a floating point type, we will return a value of the same floating point type.
		template <typename T, typename U, typename Enable = void>
		struct deduce_binary_op_result_type
		{
			typedef integer type;
		};
		template <typename T, typename U>
		struct deduce_binary_op_result_type<T,U,typename std::enable_if<std::is_floating_point<typename std::decay<T>::type>::value>::type>
		{
			typedef typename std::decay<T>::type type;
		};
		template <typename T, typename U>
		struct deduce_binary_op_result_type<T,U,typename std::enable_if<std::is_floating_point<typename std::decay<U>::type>::value>::type>
		{
			typedef typename std::decay<U>::type type;
		};
		// (integer op integral) or (integral op integer) or (integer op integer).
		template <typename T, typename Operation, typename U>
		static integer binary_op(T &&operand1, Operation &&op, U &&operand2, typename std::enable_if<
			!std::is_floating_point<typename std::decay<T>::type>::value &&
			!std::is_floating_point<typename std::decay<U>::type>::value
			>::type * = piranha_nullptr)
		{
			integer retval(std::forward<T>(operand1));
			op(retval,std::forward<U>(operand2));
			return retval;
		}
		// (integer op floating-point).
		template <typename T, typename Operation, typename U>
		static typename std::decay<U>::type binary_op(T &&operand1, Operation &&op, U &&operand2, typename std::enable_if<
			std::is_floating_point<typename std::decay<U>::type>::value>::type * = piranha_nullptr)
		{
			auto retval = static_cast<typename std::decay<U>::type>(operand1);
			op(retval,std::forward<U>(operand2));
			return retval;
		}
		// (floating-point op integer).
		template <typename T, typename Operation, typename U>
		static typename std::decay<T>::type binary_op(T &&operand1, Operation &&op, U &&operand2, typename std::enable_if<
			std::is_floating_point<typename std::decay<T>::type>::value>::type * = piranha_nullptr)
		{
			typename std::decay<T>::type retval = operand1;
			op(retval,static_cast<typename std::decay<T>::type>(operand2));
			return retval;
		}
		// Helper method to check that modulo argument has correct sign.
		static bool check_sign_for_modulo(const integer &n)
		{
			return n.sign() <= 0;
		}
		template <typename T>
		static bool check_sign_for_modulo(const T &n)
		{
			return n <= T(0);
		}
		// Construction from string.
		void construct_from_str(const char *str)
		{
			// NOTE: we want to be consistent with the string format of mp_integer.
			mp_integer::validate_string(str);
			try {
				set_flag(false);
				// NOTE: here we cast first to long long and then to int_type because direct use of lexical_cast
				// in case int_type is char leads to problems:
				// http://www.boost.org/doc/libs/release/doc/html/boost_lexical_cast/frequently_asked_questions.html
				// The cast to long long (provided str is well-formatted) is always safe, as int_type cannot be wider.
				get<int_type>() = boost::numeric_cast<int_type>(boost::lexical_cast<long long>(str));
			} catch (...) {
				// The exceptions here could come from either bad lexical cast or numeric cast. Try to construct
				// the integer from str, if it fails the appropriate exception will be thrown.
				set_flag(true);
				::new ((void *)&m_storage) ptr_type(::new mp_integer(str));
			}
		}
		// Construction from interoperable types.
		template <typename T>
		void construct_from_interop_impl(const T &x)
		{
			try {
				set_flag(false);
				// NOTE: boost::numeric_cast will truncate the result if x is floating point, and will throw an exception if the truncated
				// value is not representable by int_type.
				get<int_type>() = boost::numeric_cast<int_type>(x);
			} catch (...) {
				set_flag(true);
				::new ((void *)&m_storage) ptr_type(::new mp_integer(x));
			}
		}
		template <typename T>
		void construct_from_interop(const T &x, typename std::enable_if<std::is_floating_point<T>::value>::type * = piranha_nullptr)
		{
			mp_integer::fp_normal_check(x);
			construct_from_interop_impl(x);
		}
		template <typename T>
		void construct_from_interop(const T &n, typename std::enable_if<std::is_integral<T>::value>::type * = piranha_nullptr)
		{
			construct_from_interop_impl(n);
		}
		// Assignment from interoperable type.
		template <typename T>
		void assign_from_interop_impl(const T &x)
		{
			try {
				get<int_type>() = boost::numeric_cast<int_type>(x);
			} catch (...) {
				// If the casting fails, promote and re-attempt.
				promote();
				*get<ptr_type>() = x;
			}
		}
		template <typename T>
		void assign_from_interop(const T &x, typename std::enable_if<std::is_floating_point<T>::value>::type * = piranha_nullptr)
		{
			mp_integer::fp_normal_check(x);
			assign_from_interop_impl(x);
		}
		template <typename T>
		void assign_from_interop(const T &n, typename std::enable_if<std::is_integral<T>::value>::type * = piranha_nullptr)
		{
			assign_from_interop_impl(n);
		}
	public:
		/// Default constructor.
		/**
		 * Will initialise the integer to zero.
		 */
		integer()
		{
			set_flag(false);
			get<int_type>() = int_type(0);
		}
		/// Copy constructor.
		/**
		 * @param[in] other integer to be copied.
		 * 
		 * @throws std::bad_alloc in case of memory allocation failures.
		 */
		integer(const integer &other)
		{
			set_flag(other.get_flag());
			if (unlikely(get_flag())) {
				::new ((void *)&m_storage) ptr_type(::new mp_integer(*other.get<ptr_type>()));
			} else {
				get<int_type>() = other.get<int_type>();
			}
		}
		/// Move constructor.
		/**
		 * @param[in] other argument for move construction.
		 */
		integer(integer &&other) piranha_noexcept_spec(true)
		{
			const auto flag = other.get_flag();
			set_flag(flag);
			if (flag) {
				// Construct a new pointer moving in from other.
				::new ((void *)&m_storage) ptr_type(std::move(other.get<ptr_type>()));
			} else {
				// Same as copy construction.
				get<int_type>() = other.get<int_type>();
			}
		}
		/// Generic constructor.
		/**
		 * The supported types for \p T are the \ref interop "interoperable types".
		 * Use of other types will result in a compile-time error.
		 * In case a floating-point type is used, \p x will be truncated (i.e., rounded towards zero) before being used to construct
		 * the object.
		 * 
		 * @param[in] x object used to construct \p this.
		 * 
		 * @throws std::invalid_argument if \p x is a non-finite floating-point number.
		 * @throws std::bad_alloc in case of memory allocation errors.
		 */
		template <typename T>
		explicit integer(const T &x, typename std::enable_if<mp_integer::is_interop_type<T>::value>::type * = piranha_nullptr)
		{
			construct_from_interop(x);
		}
		/// Destructor.
		~integer() piranha_noexcept_spec(true)
		{
			destroy();
		}
		/// Constructor from \p std::string.
		/**
		 * The string format is the same expected by piranha::mp_integer.
		 * 
		 * @param[in] str string representation of the number in decimal notation.
		 * 
		 * @throws std::invalid_argument if the string is malformed.
		 * @throws std::bad_alloc in case of memory allocation errors.
		 */
		explicit integer(const std::string &str)
		{
			construct_from_str(str.c_str());
		}
		/// Constructor from C string.
		/**
		 * The string format is the same expected by piranha::mp_integer.
		 * 
		 * @param[in] str string representation of the number in decimal notation.
		 * 
		 * @throws std::invalid_argument if the string is malformed.
		 * @throws std::bad_alloc in case of memory allocation errors.
		 */
		explicit integer(const char *str)
		{
			construct_from_str(str);
		}
		/// Conversion to interoperable types.
		/**
		 * The conversion rules are the same as in the conversion operator of piranha::mp_integer.
		 * 
		 * @throws std::overflow_error if the conversion results in overflow.
		 */
		template <typename T, typename std::enable_if<mp_integer::is_interop_type<T>::value>::type*& = enabler>
		explicit operator T() const
		{
			if (unlikely(get_flag())) {
				return static_cast<T>(*get<ptr_type>());
			} else {
				// NOTE: here if T is integral, it is all good. If T is floating-point, we are relying on
				// numeric cast to guard against out-of-bounds conversions - even though from the doc it seems they
				// are not currently contemplated in int-to-float conversions:
				// http://www.boost.org/doc/libs/release/libs/numeric/conversion/doc/html/boost_numericconversion/converter___function_object.html
				try {
					return boost::numeric_cast<T>(get<int_type>());
				} catch (...) {
					piranha_throw(std::overflow_error,"overflow error in conversion of integer type");
				}
			}
		}
		/// Copy assignment operator.
		/**
		 * @param[in] other assignment argument.
		 * 
		 * @return reference to \p this.
		 * 
		 * @throws unspecified any exception thrown by the copy constructor.
		 */
		integer &operator=(const integer &other)
		{
			if (likely(this != &other)) {
				// Copy + move.
				integer tmp(other);
				*this = std::move(tmp);
			}
			return *this;
		}
		/// Move assignment operator.
		/**
		 * @param[in] other assignment argument.
		 * 
		 * @return reference to \p this.
		 */
		integer &operator=(integer &&other) piranha_noexcept_spec(true)
		{
			if (likely(this != &other)) {
				// Destroy whatever we are holding.
				destroy();
				// Set the flag same as other.
				const auto flag = other.get_flag();
				set_flag(flag);
				if (flag) {
					// Construct a new pointer moving in from other.
					::new ((void *)&m_storage) ptr_type(std::move(other.get<ptr_type>()));
				} else {
					// Simple assignment.
					get<int_type>() = other.get<int_type>();
				}
			}
			return *this;
		}
		/// Assignment operator from interoperable types.
		/**
		 * The supported types for \p T are the \ref interop "interoperable types".
		 * Use of other types will result in a compile-time error.
		 * In case a floating-point type is used, \p x will be truncated (i.e., rounded towards zero) before being assigned
		 * to the object.
		 * 
		 * @param[in] x object that will be assigned to \p this.
		 * 
		 * @return reference to \p this.
		 * 
		 * @throws std::invalid_argument if \p x is a non-finite floating-point number.
		 * @throws std::bad_alloc in case of memory allocation errors.
		 */
		template <typename T>
		typename std::enable_if<mp_integer::is_interop_type<T>::value,integer &>::type operator=(const T &x)
		{
			if (unlikely(get_flag())) {
				*get<ptr_type>() = x;
			} else {
				assign_from_interop(x);
			}
			return *this;
		}
		/// Assignment operator from C string.
		/**
		 * Equivalent to construction from string, followed by move assignmnent.
		 * 
		 * @param[in] str assignment argument.
		 * 
		 * @return reference to \p this.
		 * 
		 * @throws unspecified any exception thrown by the constructor from string.
		 */
		integer &operator=(const char *str)
		{
			// NOTE: this could be optimized if there is ever the need.
			integer tmp(str);
			*this = std::move(tmp);
			return *this;
		}
		/// Assignment operator from \p std::string.
		/**
		 * Equivalent to construction from string, followed by move assignmnent.
		 * 
		 * @param[in] str assignment argument.
		 * 
		 * @return reference to \p this.
		 * 
		 * @throws unspecified any exception thrown by the constructor from string.
		 */
		integer &operator=(const std::string &str)
		{
			return operator=(str.c_str());
		}
		/// Sign.
		/**
		 * @return 1 if <tt>this > 0</tt>, 0 if <tt>this == 0</tt> and -1 if <tt>this < 0</tt>.
		 */
		int sign() const
		{
			if (get_flag()) {
				return get<ptr_type>()->sign();
			} else {
				if (get<int_type>() > int_type(0)) {
					return 1;
				} else if (get<int_type>() < int_type(0)) {
					return -1;
				} else {
					return 0;
				}
			}
		}
		/// In-place addition.
		/**
		 * Add \p x to the current value of the piranha::integer object. This template operator is activated only if
		 * \p T is either piranha::integer or an \ref interop "interoperable type".
		 * 
		 * If \p T is piranha::integer or an integral type, the result will be exact. If \p T is a floating-point type, the following
		 * sequence of operations takes place:
		 * 
		 * - \p this is converted to an instance \p f of type \p T via the conversion operator,
		 * - \p f is added to \p x,
		 * - the result is assigned back to \p this.
		 * 
		 * @param[in] x argument for the addition.
		 * 
		 * @return reference to \p this.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 * @throws unspecified any exception resulting from operating on non-finite floating-point values or from failures in floating-point conversions.
		 */
		template <typename T>
		typename std::enable_if<std::is_same<integer,typename std::decay<T>::type>::value ||
			mp_integer::is_interop_type<typename std::decay<T>::type>::value,integer &>::type operator+=(T &&x)
		{
			return in_place(plus(),std::forward<T>(x));
		}
		/// Generic in-place addition with piranha::integer.
		/**
		 * Add a piranha::integer in-place. This template operator is activated only if \p T is an \ref interop "interoperable type" and \p I is piranha::integer.
		 * This method will first compute <tt>n + x</tt>, cast it back to \p T via \p static_cast and finally assign the result to \p x.
		 * 
		 * @param[in,out] x first argument.
		 * @param[in] n second argument.
		 * 
		 * @return reference to \p x.
		 * 
		 * @throws unspecified any exception resulting from casting piranha::integer to \p T.
		 */
		template <typename T, typename I>
		friend typename std::enable_if<mp_integer::is_interop_type<T>::value && std::is_same<typename std::decay<I>::type,integer>::value,T &>::type
			operator+=(T &x, I &&n)
		{
			x = static_cast<T>(std::forward<I>(n) + x);
			return x;
		}
		/// Generic binary addition involving piranha::integer.
		/**
		 * This template operator is activated if either:
		 * 
		 * - \p T is piranha::integer and \p U is an \ref interop "interoperable type",
		 * - \p U is piranha::integer and \p T is an \ref interop "interoperable type",
		 * - both \p T and \p U are piranha::integer.
		 * 
		 * If no floating-point types are involved, the exact result of the operation will be returned as a piranha::integer.
		 * 
		 * If one of the arguments is a floating-point value \p f of type \p F, the other argument will be converted to an instance of type \p F
		 * and added to \p f to generate the return value, wich will then be of type \p F.
		 * 
		 * @param[in] x first argument
		 * @param[in] y second argument.
		 * 
		 * @return <tt>x + y</tt>.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 * @throws unspecified any exception resulting from the conversion of piranha::integer to floating-point types.
		 */
		template <typename T, typename U>
		friend typename std::enable_if<are_binary_op_types<T,U>::value,typename deduce_binary_op_result_type<T,U>::type>::type
			operator+(T &&x, U &&y)
		{
			return binary_op(std::forward<T>(x),plus(),std::forward<U>(y));
		}
		/// Identity operation.
		/**
		 * @return copy of \p this.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 */
		integer operator+() const
		{
			return *this;
		}
		/// Prefix increment.
		/**
		 * Increment \p this by one.
		 * 
		 * @return reference to \p this after the increment.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 */
		integer &operator++()
		{
			return operator+=(1);
		}
		/// Suffix increment.
		/**
		 * Increment \p this by one and return a copy of \p this as it was before the increment.
		 * 
		 * @return copy of \p this before the increment.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 */
		integer operator++(int)
		{
			const integer retval(*this);
			++(*this);
			return retval;
		}
		/// In-place subtraction.
		/**
		 * The same rules described in operator+=() apply.
		 * 
		 * @param[in] x argument for the subtraction.
		 * 
		 * @return reference to \p this.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 * @throws unspecified any exception resulting from operating on non-finite floating-point values or from failures in floating-point conversions.
		 */
		template <typename T>
		typename std::enable_if<std::is_same<integer,typename std::decay<T>::type>::value ||
			mp_integer::is_interop_type<typename std::decay<T>::type>::value,integer &>::type operator-=(T &&x)
		{
			return in_place(minus(),std::forward<T>(x));
		}
		/// Generic in-place subtraction with piranha::integer.
		/**
		 * Subtract a piranha::integer in-place. This template operator is activated only if \p T is an \ref interop "interoperable type" and \p I is piranha::integer.
		 * This method will first compute <tt>x - n</tt>, cast it back to \p T via \p static_cast and finally assign the result to \p x.
		 * 
		 * @param[in,out] x first argument.
		 * @param[in] n second argument.
		 * 
		 * @return reference to \p x.
		 * 
		 * @throws unspecified any exception resulting from casting piranha::integer to \p T.
		 */
		template <typename T, typename I>
		friend typename std::enable_if<mp_integer::is_interop_type<T>::value && std::is_same<typename std::decay<I>::type,integer>::value,T &>::type
			operator-=(T &x, I &&n)
		{
			x = static_cast<T>(x - std::forward<I>(n));
			return x;
		}
		/// Generic binary subtraction involving piranha::integer.
		/**
		 * The implementation is equivalent to the generic binary addition operator.
		 * 
		 * @param[in] x first argument
		 * @param[in] y second argument.
		 * 
		 * @return <tt>x - y</tt>.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 * @throws unspecified any exception resulting from the conversion of piranha::integer to floating-point types.
		 */
		template <typename T, typename U>
		friend typename std::enable_if<are_binary_op_types<T,U>::value,typename deduce_binary_op_result_type<T,U>::type>::type
			operator-(T &&x, U &&y)
		{
			return binary_op(std::forward<T>(x),minus(),std::forward<U>(y));
		}
		/// In-place negation.
		/**
		 * Set \p this to \p -this.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 */
		void negate()
		{
			if (unlikely(get_flag())) {
				get<ptr_type>()->negate();
			} else {
				// NOTE: must do the computation in wide int for the
				// unlikely case in which -value cannot be represented.
				const wide_int_type result = -static_cast<wide_int_type>(get<int_type>());
				if (likely(fits_int_type(result))) {
					get<int_type>() = static_cast<int_type>(result);
				} else {
					promote();
					get<ptr_type>()->negate();
				}
			}
		}
		/// Negated copy.
		/**
		 * @return copy of \p -this.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 */
		integer operator-() const
		{
			integer retval(*this);
			retval.negate();
			return retval;
		}
		/// Prefix decrement.
		/**
		 * Decrement \p this by one and return.
		 * 
		 * @return reference to \p this.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 */
		integer &operator--()
		{
			return operator-=(1);
		}
		/// Suffix decrement.
		/**
		 * Decrement \p this by one and return a copy of \p this as it was before the decrement.
		 * 
		 * @return copy of \p this before the decrement.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 */
		integer operator--(int)
		{
			const integer retval(*this);
			--(*this);
			return retval;
		}
		/// In-place multiplication.
		/**
		 * The same rules described in operator+=() apply.
		 * 
		 * @param[in] x argument for the multiplication.
		 * 
		 * @return reference to \p this.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 * @throws unspecified any exception resulting from operating on non-finite floating-point values or from failures in floating-point conversions.
		 */
		template <typename T>
		typename std::enable_if<std::is_same<integer,typename std::decay<T>::type>::value ||
			mp_integer::is_interop_type<typename std::decay<T>::type>::value,integer &>::type operator*=(T &&x)
		{
			return in_place(times(),std::forward<T>(x));
		}
		/// Generic in-place multiplication with piranha::integer.
		/**
		 * Multiply by a piranha::integer in-place. This template operator is activated only if \p T is an \ref interop "interoperable type" and \p I is piranha::integer.
		 * This method will first compute <tt>x * n</tt>, cast it back to \p T via \p static_cast and finally assign the result to \p x.
		 * 
		 * @param[in,out] x first argument.
		 * @param[in] n second argument.
		 * 
		 * @return reference to \p x.
		 * 
		 * @throws unspecified any exception resulting from casting piranha::integer to \p T.
		 */
		template <typename T, typename I>
		friend typename std::enable_if<mp_integer::is_interop_type<T>::value && std::is_same<typename std::decay<I>::type,integer>::value,T &>::type
			operator*=(T &x, I &&n)
		{
			x = static_cast<T>(x * std::forward<I>(n));
			return x;
		}
		/// Generic binary multiplication involving piranha::integer.
		/**
		 * The implementation is equivalent to the generic binary addition operator.
		 * 
		 * @param[in] x first argument
		 * @param[in] y second argument.
		 * 
		 * @return <tt>x * y</tt>.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 * @throws unspecified any exception resulting from the conversion of piranha::integer to floating-point types.
		 */
		template <typename T, typename U>
		friend typename std::enable_if<are_binary_op_types<T,U>::value,typename deduce_binary_op_result_type<T,U>::type>::type
			operator*(T &&x, U &&y)
		{
			return binary_op(std::forward<T>(x),times(),std::forward<U>(y));
		}
		/// In-place division.
		/**
		 * The same rules described in operator+=() apply. Division by piranha::integer or by an integral type is truncated.
		 * 
		 * @param[in] x argument for the division.
		 * 
		 * @return reference to \p this.
		 * 
		 * @throws piranha::zero_division_error if \p x is zero.
		 * @throws std::bad_alloc in case of memory allocation errors.
		 * @throws unspecified any exception resulting from operating on non-finite floating-point values or from failures in floating-point conversions.
		 */
		template <typename T>
		typename std::enable_if<std::is_same<integer,typename std::decay<T>::type>::value ||
			mp_integer::is_interop_type<typename std::decay<T>::type>::value,integer &>::type operator/=(T &&x)
		{
			if (unlikely(math::is_zero(x))) {
				piranha_throw(zero_division_error,"division by zero");
			}
			return in_place(divide(),std::forward<T>(x));
		}
		/// Generic in-place division with piranha::integer.
		/**
		 * Divide by a piranha::integer in-place. This template operator is activated only if \p T is an \ref interop "interoperable type" and \p I is piranha::integer.
		 * This method will first compute <tt>x / n</tt>, cast it back to \p T via \p static_cast and finally assign the result to \p x.
		 * 
		 * @param[in,out] x first argument.
		 * @param[in] n second argument.
		 * 
		 * @return reference to \p x.
		 * 
		 * @throws piranha::zero_division_error if \p x is zero.
		 * @throws unspecified any exception resulting from casting piranha::integer to \p T.
		 */
		template <typename T, typename I>
		friend typename std::enable_if<mp_integer::is_interop_type<T>::value && std::is_same<typename std::decay<I>::type,integer>::value,T &>::type
			operator/=(T &x, I &&n)
		{
			x = static_cast<T>(x / std::forward<I>(n));
			return x;
		}
		/// Generic binary division involving piranha::integer.
		/**
		 * The implementation is equivalent to the generic binary addition operator. Division by piranha::integer or by an integral type is truncated.
		 * 
		 * @param[in] x first argument
		 * @param[in] y second argument.
		 * 
		 * @return <tt>x / y</tt>.
		 * 
		 * @throws piranha::zero_division_error if \p y is zero.
		 * @throws std::bad_alloc in case of memory allocation errors.
		 * @throws unspecified any exception resulting from the conversion of piranha::integer to floating-point types.
		 */
		template <typename T, typename U>
		friend typename std::enable_if<are_binary_op_types<T,U>::value,typename deduce_binary_op_result_type<T,U>::type>::type
			operator/(T &&x, U &&y)
		{
			if (unlikely(math::is_zero(y))) {
				piranha_throw(zero_division_error,"division by zero");
			}
			return binary_op(std::forward<T>(x),divide(),std::forward<U>(y));
		}
		/// In-place modulo operation.
		/**
		 * Sets \p this to <tt>this % n</tt>. This template operator is enabled if \p T is piranha::integer or an integral type among the \ref interop "interoperable types".
		 * \p this must be non-negative and \p n strictly positive, otherwise an \p std::invalid_argument exception will be thrown.
		 * 
		 * @param[in] n argument for the modulo operation.
		 * 
		 * @return reference to \p this.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 * @throws std::invalid_argument if <tt>n <= 0</tt> or <tt>this < 0</tt>.
		 */
		template <typename T>
		typename std::enable_if<
			(std::is_integral<typename std::decay<T>::type>::value && mp_integer::is_interop_type<typename std::decay<T>::type>::value) ||
			std::is_same<integer,typename std::decay<T>::type>::value,integer &>::type operator%=(T &&n)
		{
			if (unlikely(sign() < 0)) {
				piranha_throw(std::invalid_argument,"negative dividend");
			}
			if (unlikely(check_sign_for_modulo(n))) {
				piranha_throw(std::invalid_argument,"non-positive divisor");
			}
			return in_place(modulo(),std::forward<T>(n));
		}
		/// Generic in-place modulo operation with piranha::integer.
		/**
		 * Apply the modulo operation by a piranha::integer in-place. This template operator is activated only if \p T is an integral type
		 * among the \ref interop "interoperable types"
		 * and \p I is piranha::integer. This method will first compute <tt>x % n</tt>,
		 * cast it back to \p T via \p static_cast and finally assign the result to \p x.
		 * 
		 * @param[in,out] x first argument.
		 * @param[in] n second argument.
		 * 
		 * @return reference to \p x.
		 * 
		 * @throws std::invalid_argument if <tt>n <= 0</tt> or <tt>x < 0</tt>.
		 * @throws unspecified any exception resulting from casting piranha::integer to \p T.
		 */
		template <typename T, typename I>
		friend typename std::enable_if<std::is_integral<T>::value && mp_integer::is_interop_type<T>::value &&
			std::is_same<typename std::decay<I>::type,integer>::value,T &>::type
			operator%=(T &x, I &&n)
		{
			x = static_cast<T>(x % std::forward<I>(n));
			return x;
		}
		/// Generic binary modulo operation involving piranha::integer.
		/**
		 * This template operator is activated if either:
		 * 
		 * - \p T is piranha::integer and \p U is an integral type among the \ref interop "interoperable types",
		 * - \p U is piranha::integer and \p T is an integral type among the \ref interop "interoperable types",
		 * - both \p T and \p U are piranha::integer.
		 * 
		 * The result is always a non-negative piranha::integer.
		 * 
		 * @param[in] x first argument
		 * @param[in] y second argument.
		 * 
		 * @return <tt>x % y</tt>.
		 * 
		 * @throws std::bad_alloc in case of memory allocation errors.
		 * @throws std::invalid_argument if <tt>y <= 0</tt> or <tt>x < 0</tt>.
		 */
		template <typename T, typename U>
		friend typename std::enable_if<
			are_binary_op_types<T,U>::value && !std::is_floating_point<typename std::decay<T>::type>::value &&
			!std::is_floating_point<typename std::decay<U>::type>::value,
			typename deduce_binary_op_result_type<T,U>::type>::type
			operator%(T &&x, U &&y)
		{
			return binary_op(std::forward<T>(x),modulo(),std::forward<U>(y));
		}
		/// Stream operator overload for piranha::integer.
		/**
		 * @param[in] os output stream.
		 * @param[in] n piranha::integer to be directed to stream.
		 * 
		 * @return reference to \p os.
		 */
		friend std::ostream &operator<<(std::ostream &os, const integer &n)
		{
			if (n.get_flag()) {
				return (os << (*n.get<ptr_type>()));
			} else {
				return (os << n.get<int_type>());
			}
		}
		/// Overload input stream operator for piranha::integer.
		/**
		 * Equivalent to extracting a string from the stream and then using it to construct a piranha::integer that will be assigned to \p n.
		 * 
		 * @param[in] is input stream.
		 * @param[in,out] n piranha::integer to which the contents of the stream will be assigned.
		 * 
		 * @return reference to \p is.
		 * 
		 * @throws unspecified any exception thrown by the constructor from string of piranha::integer.
		 */
		friend std::istream &operator>>(std::istream &is, integer &n)
		{
			std::string tmp_str;
			std::getline(is,tmp_str);
			n = integer(tmp_str);
			return is;
		}
	private:
		bool		m_flag;
		storage_type	m_storage;
};

namespace detail
{

// Specialise implementation of math::is_zero for integer.
template <typename T>
struct math_is_zero_impl<T,typename std::enable_if<std::is_same<T,integer>::value>::type>
{
	static bool run(const T &n)
	{
		return n.sign() == 0;
	}
};

// Specialise implementation of math::negate for integer.
template <typename T>
struct math_negate_impl<T,typename std::enable_if<std::is_same<T,integer>::value>::type>
{
	static void run(T &n)
	{
		n.negate();
	}
};

// Specialise multadd for mp_integer.
// template <typename T>
// struct math_multiply_accumulate_impl<T,T,T,typename std::enable_if<std::is_same<T,mp_integer>::value>::type>
// {
// 	static void run(T &x, const T &y, const T &z)
// 	{
// 		x.multiply_accumulate(y,z);
// 	}
// };

}

}

namespace std
{

/// Specialization of \p std::swap for piranha::integer.
/**
 * @param[in] n1 first argument.
 * @param[in] n2 second argument.
 */
template <>
void swap(piranha::integer &n1, piranha::integer &n2)
{
	piranha::integer tmp(std::move(n1));
	n1 = std::move(n2);
	n2 = std::move(tmp);
}

}

#endif
