<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>piranha: mppp::mp_integer&lt; SSize &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemppp.html">mppp</a></li><li class="navelem"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmppp_1_1mp__integer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mppp::mp_integer&lt; SSize &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Multiprecision integer class.  
 <a href="classmppp_1_1mp__integer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7354ac1e0a2a56c3351953219c5a4082"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a7354ac1e0a2a56c3351953219c5a4082">mp_integer</a> ()=default</td></tr>
<tr class="memdesc:a7354ac1e0a2a56c3351953219c5a4082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a7354ac1e0a2a56c3351953219c5a4082">More...</a><br /></td></tr>
<tr class="separator:a7354ac1e0a2a56c3351953219c5a4082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbee3a5263b9c01642173d62f8bb196"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a5bbee3a5263b9c01642173d62f8bb196">mp_integer</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;other)=default</td></tr>
<tr class="memdesc:a5bbee3a5263b9c01642173d62f8bb196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a5bbee3a5263b9c01642173d62f8bb196">More...</a><br /></td></tr>
<tr class="separator:a5bbee3a5263b9c01642173d62f8bb196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9812e5d6af15524570657e36936ef266"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a9812e5d6af15524570657e36936ef266">mp_integer</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a9812e5d6af15524570657e36936ef266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a9812e5d6af15524570657e36936ef266">More...</a><br /></td></tr>
<tr class="separator:a9812e5d6af15524570657e36936ef266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3e9601d5fea9d13d6b212af53f6eee"><td class="memTemplParams" colspan="2">template&lt;typename T , generic_ctor_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:aab3e9601d5fea9d13d6b212af53f6eee"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aab3e9601d5fea9d13d6b212af53f6eee">mp_integer</a> (T x)</td></tr>
<tr class="memdesc:aab3e9601d5fea9d13d6b212af53f6eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic constructor.  <a href="#aab3e9601d5fea9d13d6b212af53f6eee">More...</a><br /></td></tr>
<tr class="separator:aab3e9601d5fea9d13d6b212af53f6eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91f598987148a5706fcfc92a4a9fdac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ac91f598987148a5706fcfc92a4a9fdac">mp_integer</a> (const char *s, int base=10)</td></tr>
<tr class="memdesc:ac91f598987148a5706fcfc92a4a9fdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from C string.  <a href="#ac91f598987148a5706fcfc92a4a9fdac">More...</a><br /></td></tr>
<tr class="separator:ac91f598987148a5706fcfc92a4a9fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca61d4876f75f3de21d03d23f652004"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a4ca61d4876f75f3de21d03d23f652004">mp_integer</a> (const std::string &amp;s, int base=10)</td></tr>
<tr class="memdesc:a4ca61d4876f75f3de21d03d23f652004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from C++ string (equivalent to the constructor from C string).  <a href="#a4ca61d4876f75f3de21d03d23f652004">More...</a><br /></td></tr>
<tr class="separator:a4ca61d4876f75f3de21d03d23f652004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade57b8774cb7197cd3350f3f1a434d52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ade57b8774cb7197cd3350f3f1a434d52">mp_integer</a> (const ::mpz_t n)</td></tr>
<tr class="memdesc:ade57b8774cb7197cd3350f3f1a434d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from <code>mpz_t</code>.  <a href="#ade57b8774cb7197cd3350f3f1a434d52">More...</a><br /></td></tr>
<tr class="separator:ade57b8774cb7197cd3350f3f1a434d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac166758f51d6d7240624e2e19e47693d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ac166758f51d6d7240624e2e19e47693d">operator=</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;other)=default</td></tr>
<tr class="memdesc:ac166758f51d6d7240624e2e19e47693d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#ac166758f51d6d7240624e2e19e47693d">More...</a><br /></td></tr>
<tr class="separator:ac166758f51d6d7240624e2e19e47693d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab554b69f9b90a853bce74bbdc660a28e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ab554b69f9b90a853bce74bbdc660a28e">operator=</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:ab554b69f9b90a853bce74bbdc660a28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#ab554b69f9b90a853bce74bbdc660a28e">More...</a><br /></td></tr>
<tr class="separator:ab554b69f9b90a853bce74bbdc660a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01310c763f9bb7d333d86d144d0fea8e"><td class="memTemplParams" colspan="2">template&lt;typename T , generic_assignment_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a01310c763f9bb7d333d86d144d0fea8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a01310c763f9bb7d333d86d144d0fea8e">operator=</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a01310c763f9bb7d333d86d144d0fea8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic assignment operator.  <a href="#a01310c763f9bb7d333d86d144d0fea8e">More...</a><br /></td></tr>
<tr class="separator:a01310c763f9bb7d333d86d144d0fea8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a519c1e12c63e885d2f4834d3be68f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a24a519c1e12c63e885d2f4834d3be68f">is_static</a> () const</td></tr>
<tr class="memdesc:a24a519c1e12c63e885d2f4834d3be68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for static storage.  <a href="#a24a519c1e12c63e885d2f4834d3be68f">More...</a><br /></td></tr>
<tr class="separator:a24a519c1e12c63e885d2f4834d3be68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4291e282795b21b8a36a4dbbf946ae25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a4291e282795b21b8a36a4dbbf946ae25">is_dynamic</a> () const</td></tr>
<tr class="memdesc:a4291e282795b21b8a36a4dbbf946ae25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for dynamic storage.  <a href="#a4291e282795b21b8a36a4dbbf946ae25">More...</a><br /></td></tr>
<tr class="separator:a4291e282795b21b8a36a4dbbf946ae25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ff4d52c9d0216801f521870bb921c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a44ff4d52c9d0216801f521870bb921c0">to_string</a> (int base=10) const</td></tr>
<tr class="memdesc:a44ff4d52c9d0216801f521870bb921c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to string.  <a href="#a44ff4d52c9d0216801f521870bb921c0">More...</a><br /></td></tr>
<tr class="separator:a44ff4d52c9d0216801f521870bb921c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a003134d2ef2312e85131f780c4946"><td class="memTemplParams" colspan="2">template&lt;typename T , generic_conversion_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad7a003134d2ef2312e85131f780c4946"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ad7a003134d2ef2312e85131f780c4946">operator T</a> () const</td></tr>
<tr class="memdesc:ad7a003134d2ef2312e85131f780c4946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic conversion operator.  <a href="#ad7a003134d2ef2312e85131f780c4946">More...</a><br /></td></tr>
<tr class="separator:ad7a003134d2ef2312e85131f780c4946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18648a14a792ff12dc508125eff7714"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#af18648a14a792ff12dc508125eff7714">promote</a> ()</td></tr>
<tr class="memdesc:af18648a14a792ff12dc508125eff7714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote to dynamic storage.  <a href="#af18648a14a792ff12dc508125eff7714">More...</a><br /></td></tr>
<tr class="separator:af18648a14a792ff12dc508125eff7714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a59f7c0ddf4c5939ce7f7249bb3ad90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a7a59f7c0ddf4c5939ce7f7249bb3ad90">demote</a> ()</td></tr>
<tr class="memdesc:a7a59f7c0ddf4c5939ce7f7249bb3ad90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demote to static storage.  <a href="#a7a59f7c0ddf4c5939ce7f7249bb3ad90">More...</a><br /></td></tr>
<tr class="separator:a7a59f7c0ddf4c5939ce7f7249bb3ad90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5524e25c7f364051bb5d3857b1f21f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#acb5524e25c7f364051bb5d3857b1f21f">nbits</a> () const</td></tr>
<tr class="memdesc:acb5524e25c7f364051bb5d3857b1f21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bits.  <a href="#acb5524e25c7f364051bb5d3857b1f21f">More...</a><br /></td></tr>
<tr class="separator:acb5524e25c7f364051bb5d3857b1f21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb5d83fa57cbc9042ec247a8a8ea46a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a6cb5d83fa57cbc9042ec247a8a8ea46a">size</a> () const</td></tr>
<tr class="memdesc:a6cb5d83fa57cbc9042ec247a8a8ea46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in limbs.  <a href="#a6cb5d83fa57cbc9042ec247a8a8ea46a">More...</a><br /></td></tr>
<tr class="separator:a6cb5d83fa57cbc9042ec247a8a8ea46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d58df878c6390947e9547c4c26cc31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ae7d58df878c6390947e9547c4c26cc31">sgn</a> () const</td></tr>
<tr class="memdesc:ae7d58df878c6390947e9547c4c26cc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign.  <a href="#ae7d58df878c6390947e9547c4c26cc31">More...</a><br /></td></tr>
<tr class="separator:ae7d58df878c6390947e9547c4c26cc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea6b849d829e76086fbeba66fee1337"><td class="memItemLeft" align="right" valign="top">mpz_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aaea6b849d829e76086fbeba66fee1337">get_mpz_view</a> () const</td></tr>
<tr class="memdesc:aaea6b849d829e76086fbeba66fee1337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <code>mpz_t</code> view.  <a href="#aaea6b849d829e76086fbeba66fee1337">More...</a><br /></td></tr>
<tr class="separator:aaea6b849d829e76086fbeba66fee1337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902f748104522a58f9a41cdc8355dbe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a902f748104522a58f9a41cdc8355dbe5">neg</a> ()</td></tr>
<tr class="memdesc:a902f748104522a58f9a41cdc8355dbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate in-place.  <a href="#a902f748104522a58f9a41cdc8355dbe5">More...</a><br /></td></tr>
<tr class="separator:a902f748104522a58f9a41cdc8355dbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0346e69c2267177be4ceee53507cee82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a0346e69c2267177be4ceee53507cee82">operator+</a> () const</td></tr>
<tr class="memdesc:a0346e69c2267177be4ceee53507cee82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity operator.  <a href="#a0346e69c2267177be4ceee53507cee82">More...</a><br /></td></tr>
<tr class="separator:a0346e69c2267177be4ceee53507cee82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08982b7fea3fc3510a01537ba4f7f0cd"><td class="memTemplParams" colspan="2">template&lt;typename T , in_place_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a08982b7fea3fc3510a01537ba4f7f0cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a08982b7fea3fc3510a01537ba4f7f0cd">operator+=</a> (const T &amp;op)</td></tr>
<tr class="memdesc:a08982b7fea3fc3510a01537ba4f7f0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place addition operator.  <a href="#a08982b7fea3fc3510a01537ba4f7f0cd">More...</a><br /></td></tr>
<tr class="separator:a08982b7fea3fc3510a01537ba4f7f0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59bace88e3bb525729741722b6dfddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ab59bace88e3bb525729741722b6dfddb">operator++</a> ()</td></tr>
<tr class="memdesc:ab59bace88e3bb525729741722b6dfddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix increment.  <a href="#ab59bace88e3bb525729741722b6dfddb">More...</a><br /></td></tr>
<tr class="separator:ab59bace88e3bb525729741722b6dfddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af068ad45e35103ddcff3e47f754424fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#af068ad45e35103ddcff3e47f754424fc">operator++</a> (int)</td></tr>
<tr class="memdesc:af068ad45e35103ddcff3e47f754424fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suffix increment.  <a href="#af068ad45e35103ddcff3e47f754424fc">More...</a><br /></td></tr>
<tr class="separator:af068ad45e35103ddcff3e47f754424fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb22f4a502aba22abd8e80d6e504660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#afbb22f4a502aba22abd8e80d6e504660">operator-</a> () const</td></tr>
<tr class="memdesc:afbb22f4a502aba22abd8e80d6e504660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negated copy.  <a href="#afbb22f4a502aba22abd8e80d6e504660">More...</a><br /></td></tr>
<tr class="separator:afbb22f4a502aba22abd8e80d6e504660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf948884125604bbe4ecaed039ebdc4e"><td class="memTemplParams" colspan="2">template&lt;typename T , in_place_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:adf948884125604bbe4ecaed039ebdc4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#adf948884125604bbe4ecaed039ebdc4e">operator-=</a> (const T &amp;op)</td></tr>
<tr class="memdesc:adf948884125604bbe4ecaed039ebdc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place subtraction operator.  <a href="#adf948884125604bbe4ecaed039ebdc4e">More...</a><br /></td></tr>
<tr class="separator:adf948884125604bbe4ecaed039ebdc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba37db6ac25aea4874b35a15becfc1d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aba37db6ac25aea4874b35a15becfc1d4">operator--</a> ()</td></tr>
<tr class="memdesc:aba37db6ac25aea4874b35a15becfc1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix decrement.  <a href="#aba37db6ac25aea4874b35a15becfc1d4">More...</a><br /></td></tr>
<tr class="separator:aba37db6ac25aea4874b35a15becfc1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb0c0008d8d2dab7849ae0ec33d222e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aedb0c0008d8d2dab7849ae0ec33d222e">operator--</a> (int)</td></tr>
<tr class="memdesc:aedb0c0008d8d2dab7849ae0ec33d222e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suffix decrement.  <a href="#aedb0c0008d8d2dab7849ae0ec33d222e">More...</a><br /></td></tr>
<tr class="separator:aedb0c0008d8d2dab7849ae0ec33d222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee4c146f26a787ac58cb83c988eeaa0"><td class="memTemplParams" colspan="2">template&lt;typename T , in_place_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1ee4c146f26a787ac58cb83c988eeaa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a1ee4c146f26a787ac58cb83c988eeaa0">operator*=</a> (const T &amp;op)</td></tr>
<tr class="memdesc:a1ee4c146f26a787ac58cb83c988eeaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place multiplication operator.  <a href="#a1ee4c146f26a787ac58cb83c988eeaa0">More...</a><br /></td></tr>
<tr class="separator:a1ee4c146f26a787ac58cb83c988eeaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0de449356099b21d522383b816deee3"><td class="memTemplParams" colspan="2">template&lt;typename T , in_place_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa0de449356099b21d522383b816deee3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aa0de449356099b21d522383b816deee3">operator/=</a> (const T &amp;d)</td></tr>
<tr class="memdesc:aa0de449356099b21d522383b816deee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place division operator.  <a href="#aa0de449356099b21d522383b816deee3">More...</a><br /></td></tr>
<tr class="separator:aa0de449356099b21d522383b816deee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf98f8995e11f8b8a8a76e71fa33b067"><td class="memTemplParams" colspan="2">template&lt;typename T , in_place_mod_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:abf98f8995e11f8b8a8a76e71fa33b067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#abf98f8995e11f8b8a8a76e71fa33b067">operator%=</a> (const T &amp;d)</td></tr>
<tr class="memdesc:abf98f8995e11f8b8a8a76e71fa33b067"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place modulo operator.  <a href="#abf98f8995e11f8b8a8a76e71fa33b067">More...</a><br /></td></tr>
<tr class="separator:abf98f8995e11f8b8a8a76e71fa33b067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a557db52761f34d11bb26aa7327441e"><td class="memTemplParams" colspan="2">template&lt;typename T , shift_op_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6a557db52761f34d11bb26aa7327441e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a6a557db52761f34d11bb26aa7327441e">operator&lt;&lt;=</a> (T s)</td></tr>
<tr class="memdesc:a6a557db52761f34d11bb26aa7327441e"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place left shift operator.  <a href="#a6a557db52761f34d11bb26aa7327441e">More...</a><br /></td></tr>
<tr class="separator:a6a557db52761f34d11bb26aa7327441e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5ec57c32b3ca8fe788b496f1c6a2f3"><td class="memTemplParams" colspan="2">template&lt;typename T , shift_op_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3b5ec57c32b3ca8fe788b496f1c6a2f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a3b5ec57c32b3ca8fe788b496f1c6a2f3">operator&gt;&gt;=</a> (T s)</td></tr>
<tr class="memdesc:a3b5ec57c32b3ca8fe788b496f1c6a2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place right shift operator.  <a href="#a3b5ec57c32b3ca8fe788b496f1c6a2f3">More...</a><br /></td></tr>
<tr class="separator:a3b5ec57c32b3ca8fe788b496f1c6a2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb1bb36658f0142ace086c63f0c1e62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aefb1bb36658f0142ace086c63f0c1e62">abs</a> ()</td></tr>
<tr class="memdesc:aefb1bb36658f0142ace086c63f0c1e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place absolute value.  <a href="#aefb1bb36658f0142ace086c63f0c1e62">More...</a><br /></td></tr>
<tr class="separator:aefb1bb36658f0142ace086c63f0c1e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75ea34040586a5feb96c5440d2b412b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ae75ea34040586a5feb96c5440d2b412b">nextprime</a> ()</td></tr>
<tr class="memdesc:ae75ea34040586a5feb96c5440d2b412b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute next prime number (in-place version).  <a href="#ae75ea34040586a5feb96c5440d2b412b">More...</a><br /></td></tr>
<tr class="separator:ae75ea34040586a5feb96c5440d2b412b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecd20fc837c9fbd7ca991feb95363c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a2ecd20fc837c9fbd7ca991feb95363c5">probab_prime_p</a> (int reps=25) const</td></tr>
<tr class="memdesc:a2ecd20fc837c9fbd7ca991feb95363c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test primality.  <a href="#a2ecd20fc837c9fbd7ca991feb95363c5">More...</a><br /></td></tr>
<tr class="separator:a2ecd20fc837c9fbd7ca991feb95363c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dd8308e13db9a868396a5cc1f9fbf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ad6dd8308e13db9a868396a5cc1f9fbf0">sqrt</a> ()</td></tr>
<tr class="memdesc:ad6dd8308e13db9a868396a5cc1f9fbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer square root (in-place version).  <a href="#ad6dd8308e13db9a868396a5cc1f9fbf0">More...</a><br /></td></tr>
<tr class="separator:ad6dd8308e13db9a868396a5cc1f9fbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91c0265fec0a5cc5665d6fa39d7c367"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ad91c0265fec0a5cc5665d6fa39d7c367">odd_p</a> () const</td></tr>
<tr class="memdesc:ad91c0265fec0a5cc5665d6fa39d7c367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if value is odd.  <a href="#ad91c0265fec0a5cc5665d6fa39d7c367">More...</a><br /></td></tr>
<tr class="separator:ad91c0265fec0a5cc5665d6fa39d7c367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4c26973a60fdb13ca733e7877b54f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aff4c26973a60fdb13ca733e7877b54f0">even_p</a> () const</td></tr>
<tr class="memdesc:aff4c26973a60fdb13ca733e7877b54f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if value is even.  <a href="#aff4c26973a60fdb13ca733e7877b54f0">More...</a><br /></td></tr>
<tr class="separator:aff4c26973a60fdb13ca733e7877b54f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cc8760d544641a0c0eabd4f68e5828"><td class="memItemLeft" align="right" valign="top">mppp_impl::integer_union&lt; SSize &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ac1cc8760d544641a0c0eabd4f68e5828">_get_union</a> ()</td></tr>
<tr class="memdesc:ac1cc8760d544641a0c0eabd4f68e5828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the internal union.  <a href="#ac1cc8760d544641a0c0eabd4f68e5828">More...</a><br /></td></tr>
<tr class="separator:ac1cc8760d544641a0c0eabd4f68e5828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1d93c41ac2b57881a09a39af223e9b"><td class="memItemLeft" align="right" valign="top">const mppp_impl::integer_union&lt; SSize &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a2f1d93c41ac2b57881a09a39af223e9b">_get_union</a> () const</td></tr>
<tr class="memdesc:a2f1d93c41ac2b57881a09a39af223e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the internal union.  <a href="#a2f1d93c41ac2b57881a09a39af223e9b">More...</a><br /></td></tr>
<tr class="separator:a2f1d93c41ac2b57881a09a39af223e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838018dde1f7c7f142a496ae716a53cc"><td class="memItemLeft" align="right" valign="top">std::remove_extent&lt;::mpz_t &gt;::type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a838018dde1f7c7f142a496ae716a53cc">get_mpz_t</a> ()</td></tr>
<tr class="memdesc:a838018dde1f7c7f142a496ae716a53cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the dynamic storage.  <a href="#a838018dde1f7c7f142a496ae716a53cc">More...</a><br /></td></tr>
<tr class="separator:a838018dde1f7c7f142a496ae716a53cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4bf2290fa0f4da953bc21a41154599"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a7b4bf2290fa0f4da953bc21a41154599">is_zero</a> () const</td></tr>
<tr class="memdesc:a7b4bf2290fa0f4da953bc21a41154599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the value is zero.  <a href="#a7b4bf2290fa0f4da953bc21a41154599">More...</a><br /></td></tr>
<tr class="separator:a7b4bf2290fa0f4da953bc21a41154599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac214a97cb921eeeedbbe3af0b515b759"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ac214a97cb921eeeedbbe3af0b515b759">is_one</a> () const</td></tr>
<tr class="memdesc:ac214a97cb921eeeedbbe3af0b515b759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the value is equal to one.  <a href="#ac214a97cb921eeeedbbe3af0b515b759">More...</a><br /></td></tr>
<tr class="separator:ac214a97cb921eeeedbbe3af0b515b759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d34786e208468d1e04c24ddd99f880d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a2d34786e208468d1e04c24ddd99f880d">is_negative_one</a> () const</td></tr>
<tr class="memdesc:a2d34786e208468d1e04c24ddd99f880d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the value is equal to minus one.  <a href="#a2d34786e208468d1e04c24ddd99f880d">More...</a><br /></td></tr>
<tr class="separator:a2d34786e208468d1e04c24ddd99f880d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a696550214e9a637fb712abfa2dddccd7"><td class="memItemLeft" align="right" valign="top"><a id="a696550214e9a637fb712abfa2dddccd7"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a696550214e9a637fb712abfa2dddccd7">ssize</a> = SSize</td></tr>
<tr class="memdesc:a696550214e9a637fb712abfa2dddccd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the template parameter <code>SSize</code>. <br /></td></tr>
<tr class="separator:a696550214e9a637fb712abfa2dddccd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abd8dcf542bf7e232bdae9bd7ad3d1ce7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#abd8dcf542bf7e232bdae9bd7ad3d1ce7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:abd8dcf542bf7e232bdae9bd7ad3d1ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>.  <a href="#abd8dcf542bf7e232bdae9bd7ad3d1ce7">More...</a><br /></td></tr>
<tr class="separator:abd8dcf542bf7e232bdae9bd7ad3d1ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aa7c55047cca7dce63938a1f6bf6d1"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aa2aa7c55047cca7dce63938a1f6bf6d1">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:aa2aa7c55047cca7dce63938a1f6bf6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream operator for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>.  <a href="#aa2aa7c55047cca7dce63938a1f6bf6d1">More...</a><br /></td></tr>
<tr class="separator:aa2aa7c55047cca7dce63938a1f6bf6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad665a1752430eeb5be998576249ee2d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ad665a1752430eeb5be998576249ee2d4">sgn</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:ad665a1752430eeb5be998576249ee2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign function.  <a href="#ad665a1752430eeb5be998576249ee2d4">More...</a><br /></td></tr>
<tr class="separator:ad665a1752430eeb5be998576249ee2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e3feee7ea6fe09f6bbf55e2b4f004e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ac0e3feee7ea6fe09f6bbf55e2b4f004e">neg</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:ac0e3feee7ea6fe09f6bbf55e2b4f004e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary negation.  <a href="#ac0e3feee7ea6fe09f6bbf55e2b4f004e">More...</a><br /></td></tr>
<tr class="separator:ac0e3feee7ea6fe09f6bbf55e2b4f004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16af02bf463abfad2ecd6eff9e51a87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aa16af02bf463abfad2ecd6eff9e51a87">neg</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:aa16af02bf463abfad2ecd6eff9e51a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary negation.  <a href="#aa16af02bf463abfad2ecd6eff9e51a87">More...</a><br /></td></tr>
<tr class="separator:aa16af02bf463abfad2ecd6eff9e51a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b71854e924730f62da03c77b1eaeae2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a5b71854e924730f62da03c77b1eaeae2">add</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op1, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op2)</td></tr>
<tr class="memdesc:a5b71854e924730f62da03c77b1eaeae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary add.  <a href="#a5b71854e924730f62da03c77b1eaeae2">More...</a><br /></td></tr>
<tr class="separator:a5b71854e924730f62da03c77b1eaeae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cad8b55dd4f168ea18fc13eba7625b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a26cad8b55dd4f168ea18fc13eba7625b"><td class="memTemplItemLeft" align="right" valign="top">common_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a26cad8b55dd4f168ea18fc13eba7625b">operator+</a> (const T &amp;op1, const U &amp;op2)</td></tr>
<tr class="memdesc:a26cad8b55dd4f168ea18fc13eba7625b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary addition operator.  <a href="#a26cad8b55dd4f168ea18fc13eba7625b">More...</a><br /></td></tr>
<tr class="separator:a26cad8b55dd4f168ea18fc13eba7625b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1816b5da4d95b902265b84445d82a77"><td class="memTemplParams" colspan="2">template&lt;typename T , in_place_lenabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:af1816b5da4d95b902265b84445d82a77"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#af1816b5da4d95b902265b84445d82a77">operator+=</a> (T &amp;x, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:af1816b5da4d95b902265b84445d82a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place addition for interoperable types.  <a href="#af1816b5da4d95b902265b84445d82a77">More...</a><br /></td></tr>
<tr class="separator:af1816b5da4d95b902265b84445d82a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69edb625257e7c83b8def5aed14c91d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a69edb625257e7c83b8def5aed14c91d6">sub</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op1, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op2)</td></tr>
<tr class="memdesc:a69edb625257e7c83b8def5aed14c91d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary subtraction.  <a href="#a69edb625257e7c83b8def5aed14c91d6">More...</a><br /></td></tr>
<tr class="separator:a69edb625257e7c83b8def5aed14c91d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189e6a7960af40d12506db99d7b32f70"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a189e6a7960af40d12506db99d7b32f70"><td class="memTemplItemLeft" align="right" valign="top">common_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a189e6a7960af40d12506db99d7b32f70">operator-</a> (const T &amp;op1, const U &amp;op2)</td></tr>
<tr class="memdesc:a189e6a7960af40d12506db99d7b32f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary subtraction operator.  <a href="#a189e6a7960af40d12506db99d7b32f70">More...</a><br /></td></tr>
<tr class="separator:a189e6a7960af40d12506db99d7b32f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace77778f863c105fea009927ef80a1a2"><td class="memTemplParams" colspan="2">template&lt;typename T , in_place_lenabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:ace77778f863c105fea009927ef80a1a2"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ace77778f863c105fea009927ef80a1a2">operator-=</a> (T &amp;x, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:ace77778f863c105fea009927ef80a1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place subtraction for interoperable types.  <a href="#ace77778f863c105fea009927ef80a1a2">More...</a><br /></td></tr>
<tr class="separator:ace77778f863c105fea009927ef80a1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00247339df4f51c30cf2abc0c0d4e265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a00247339df4f51c30cf2abc0c0d4e265">add_ui</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op1, unsigned long op2)</td></tr>
<tr class="memdesc:a00247339df4f51c30cf2abc0c0d4e265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary add with <code>unsigned long</code>.  <a href="#a00247339df4f51c30cf2abc0c0d4e265">More...</a><br /></td></tr>
<tr class="separator:a00247339df4f51c30cf2abc0c0d4e265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9a5936e8219c35f795b0011d72032d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#acb9a5936e8219c35f795b0011d72032d">mul</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op1, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op2)</td></tr>
<tr class="memdesc:acb9a5936e8219c35f795b0011d72032d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary multiplication.  <a href="#acb9a5936e8219c35f795b0011d72032d">More...</a><br /></td></tr>
<tr class="separator:acb9a5936e8219c35f795b0011d72032d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068c436c68c530782a4a2192eb905577"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a068c436c68c530782a4a2192eb905577"><td class="memTemplItemLeft" align="right" valign="top">common_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a068c436c68c530782a4a2192eb905577">operator*</a> (const T &amp;op1, const U &amp;op2)</td></tr>
<tr class="memdesc:a068c436c68c530782a4a2192eb905577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary multiplication operator.  <a href="#a068c436c68c530782a4a2192eb905577">More...</a><br /></td></tr>
<tr class="separator:a068c436c68c530782a4a2192eb905577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508b02570a977b40b7152c2464312dd0"><td class="memTemplParams" colspan="2">template&lt;typename T , in_place_lenabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a508b02570a977b40b7152c2464312dd0"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a508b02570a977b40b7152c2464312dd0">operator*=</a> (T &amp;x, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:a508b02570a977b40b7152c2464312dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place multiplication for interoperable types.  <a href="#a508b02570a977b40b7152c2464312dd0">More...</a><br /></td></tr>
<tr class="separator:a508b02570a977b40b7152c2464312dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef60ade1e411f1e5cefe0c3ca86adbf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aef60ade1e411f1e5cefe0c3ca86adbf7">addmul</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op1, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op2)</td></tr>
<tr class="memdesc:aef60ade1e411f1e5cefe0c3ca86adbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary multiplyâ€“accumulate.  <a href="#aef60ade1e411f1e5cefe0c3ca86adbf7">More...</a><br /></td></tr>
<tr class="separator:aef60ade1e411f1e5cefe0c3ca86adbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa559800b0d25dd89e2c9af9ed4a4f8df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aa559800b0d25dd89e2c9af9ed4a4f8df">tdiv_qr</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;q, <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;r, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;d)</td></tr>
<tr class="memdesc:aa559800b0d25dd89e2c9af9ed4a4f8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary truncated division.  <a href="#aa559800b0d25dd89e2c9af9ed4a4f8df">More...</a><br /></td></tr>
<tr class="separator:aa559800b0d25dd89e2c9af9ed4a4f8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d53b543cd48875c58623644935b5fea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a3d53b543cd48875c58623644935b5fea"><td class="memTemplItemLeft" align="right" valign="top">common_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a3d53b543cd48875c58623644935b5fea">operator/</a> (const T &amp;n, const U &amp;d)</td></tr>
<tr class="memdesc:a3d53b543cd48875c58623644935b5fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary division operator.  <a href="#a3d53b543cd48875c58623644935b5fea">More...</a><br /></td></tr>
<tr class="separator:a3d53b543cd48875c58623644935b5fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc8f6ab02edcd3600d5a5f5458cca5c"><td class="memTemplParams" colspan="2">template&lt;typename T , in_place_lenabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4cc8f6ab02edcd3600d5a5f5458cca5c"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a4cc8f6ab02edcd3600d5a5f5458cca5c">operator/=</a> (T &amp;x, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:a4cc8f6ab02edcd3600d5a5f5458cca5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place division for interoperable types.  <a href="#a4cc8f6ab02edcd3600d5a5f5458cca5c">More...</a><br /></td></tr>
<tr class="separator:a4cc8f6ab02edcd3600d5a5f5458cca5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530fbdd0bc604743f5a6024db7d952ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a530fbdd0bc604743f5a6024db7d952ea"><td class="memTemplItemLeft" align="right" valign="top">common_mod_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a530fbdd0bc604743f5a6024db7d952ea">operator%</a> (const T &amp;n, const U &amp;d)</td></tr>
<tr class="memdesc:a530fbdd0bc604743f5a6024db7d952ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary modulo operator.  <a href="#a530fbdd0bc604743f5a6024db7d952ea">More...</a><br /></td></tr>
<tr class="separator:a530fbdd0bc604743f5a6024db7d952ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788d256d0a66f0aefc370c53d6a81a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a788d256d0a66f0aefc370c53d6a81a7a">mul_2exp</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n, ::mp_bitcnt_t s)</td></tr>
<tr class="memdesc:a788d256d0a66f0aefc370c53d6a81a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary left shift.  <a href="#a788d256d0a66f0aefc370c53d6a81a7a">More...</a><br /></td></tr>
<tr class="separator:a788d256d0a66f0aefc370c53d6a81a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90405a1785f3ed5a08602b1de674a6cc"><td class="memTemplParams" colspan="2">template&lt;typename T , shift_op_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a90405a1785f3ed5a08602b1de674a6cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a90405a1785f3ed5a08602b1de674a6cc">operator&lt;&lt;</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n, T s)</td></tr>
<tr class="memdesc:a90405a1785f3ed5a08602b1de674a6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left shift operator.  <a href="#a90405a1785f3ed5a08602b1de674a6cc">More...</a><br /></td></tr>
<tr class="separator:a90405a1785f3ed5a08602b1de674a6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0595f2a8d55ed847eb7effd18e73c1fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a0595f2a8d55ed847eb7effd18e73c1fa">tdiv_q_2exp</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n, ::mp_bitcnt_t s)</td></tr>
<tr class="memdesc:a0595f2a8d55ed847eb7effd18e73c1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary right shift.  <a href="#a0595f2a8d55ed847eb7effd18e73c1fa">More...</a><br /></td></tr>
<tr class="separator:a0595f2a8d55ed847eb7effd18e73c1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98289359023c0c35545bce1e830095a3"><td class="memTemplParams" colspan="2">template&lt;typename T , shift_op_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a98289359023c0c35545bce1e830095a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a98289359023c0c35545bce1e830095a3">operator&gt;&gt;</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n, T s)</td></tr>
<tr class="memdesc:a98289359023c0c35545bce1e830095a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right shift operator.  <a href="#a98289359023c0c35545bce1e830095a3">More...</a><br /></td></tr>
<tr class="separator:a98289359023c0c35545bce1e830095a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b64af245a47ede5ed7d8aaf25c2837"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ad6b64af245a47ede5ed7d8aaf25c2837">cmp</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op1, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op2)</td></tr>
<tr class="memdesc:ad6b64af245a47ede5ed7d8aaf25c2837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison function for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>.  <a href="#ad6b64af245a47ede5ed7d8aaf25c2837">More...</a><br /></td></tr>
<tr class="separator:ad6b64af245a47ede5ed7d8aaf25c2837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29e79b650b2c97f2ca569bf4f848812"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac29e79b650b2c97f2ca569bf4f848812"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ac29e79b650b2c97f2ca569bf4f848812">operator==</a> (const T &amp;op1, const U &amp;op2)</td></tr>
<tr class="memdesc:ac29e79b650b2c97f2ca569bf4f848812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#ac29e79b650b2c97f2ca569bf4f848812">More...</a><br /></td></tr>
<tr class="separator:ac29e79b650b2c97f2ca569bf4f848812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff50d5e505ab645606b42f1105edac0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:acff50d5e505ab645606b42f1105edac0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#acff50d5e505ab645606b42f1105edac0">operator!=</a> (const T &amp;op1, const U &amp;op2)</td></tr>
<tr class="memdesc:acff50d5e505ab645606b42f1105edac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#acff50d5e505ab645606b42f1105edac0">More...</a><br /></td></tr>
<tr class="separator:acff50d5e505ab645606b42f1105edac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7ba9c91a38f89cda168194377e1f3a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3b7ba9c91a38f89cda168194377e1f3a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a3b7ba9c91a38f89cda168194377e1f3a">operator&lt;</a> (const T &amp;op1, const U &amp;op2)</td></tr>
<tr class="memdesc:a3b7ba9c91a38f89cda168194377e1f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator.  <a href="#a3b7ba9c91a38f89cda168194377e1f3a">More...</a><br /></td></tr>
<tr class="separator:a3b7ba9c91a38f89cda168194377e1f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04275962fd456cf9fe5f7bba3c7d5f7f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a04275962fd456cf9fe5f7bba3c7d5f7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a04275962fd456cf9fe5f7bba3c7d5f7f">operator&gt;=</a> (const T &amp;op1, const U &amp;op2)</td></tr>
<tr class="memdesc:a04275962fd456cf9fe5f7bba3c7d5f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal operator.  <a href="#a04275962fd456cf9fe5f7bba3c7d5f7f">More...</a><br /></td></tr>
<tr class="separator:a04275962fd456cf9fe5f7bba3c7d5f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55357bd4da2238fd732d5884e9ed2ed"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae55357bd4da2238fd732d5884e9ed2ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ae55357bd4da2238fd732d5884e9ed2ed">operator&gt;</a> (const T &amp;op1, const U &amp;op2)</td></tr>
<tr class="memdesc:ae55357bd4da2238fd732d5884e9ed2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator.  <a href="#ae55357bd4da2238fd732d5884e9ed2ed">More...</a><br /></td></tr>
<tr class="separator:ae55357bd4da2238fd732d5884e9ed2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f87804e8d85bfc4cb81744af39ec852"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9f87804e8d85bfc4cb81744af39ec852"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a9f87804e8d85bfc4cb81744af39ec852">operator&lt;=</a> (const T &amp;op1, const U &amp;op2)</td></tr>
<tr class="memdesc:a9f87804e8d85bfc4cb81744af39ec852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal operator.  <a href="#a9f87804e8d85bfc4cb81744af39ec852">More...</a><br /></td></tr>
<tr class="separator:a9f87804e8d85bfc4cb81744af39ec852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdda8d1f4c0e3f5986f47411646fe78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a3fdda8d1f4c0e3f5986f47411646fe78">pow_ui</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;base, unsigned long exp)</td></tr>
<tr class="memdesc:a3fdda8d1f4c0e3f5986f47411646fe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary exponentiation.  <a href="#a3fdda8d1f4c0e3f5986f47411646fe78">More...</a><br /></td></tr>
<tr class="separator:a3fdda8d1f4c0e3f5986f47411646fe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb43aedb7c011ecd421fc452c3329ba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#acb43aedb7c011ecd421fc452c3329ba3">pow_ui</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;base, unsigned long exp)</td></tr>
<tr class="memdesc:acb43aedb7c011ecd421fc452c3329ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary exponentiation.  <a href="#acb43aedb7c011ecd421fc452c3329ba3">More...</a><br /></td></tr>
<tr class="separator:acb43aedb7c011ecd421fc452c3329ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000b510b971a4827a6e60e6811952d5e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a000b510b971a4827a6e60e6811952d5e"><td class="memTemplItemLeft" align="right" valign="top">common_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a000b510b971a4827a6e60e6811952d5e">pow</a> (const T &amp;base, const U &amp;exp)</td></tr>
<tr class="memdesc:a000b510b971a4827a6e60e6811952d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic binary exponentiation.  <a href="#a000b510b971a4827a6e60e6811952d5e">More...</a><br /></td></tr>
<tr class="separator:a000b510b971a4827a6e60e6811952d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580904fcc3bdca4261460d1355c40875"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a580904fcc3bdca4261460d1355c40875">abs</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:a580904fcc3bdca4261460d1355c40875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary absolute value.  <a href="#a580904fcc3bdca4261460d1355c40875">More...</a><br /></td></tr>
<tr class="separator:a580904fcc3bdca4261460d1355c40875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e6153ad7bd9fa27523ef733e1153b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#aa9e6153ad7bd9fa27523ef733e1153b4">abs</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:aa9e6153ad7bd9fa27523ef733e1153b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary absolute value.  <a href="#aa9e6153ad7bd9fa27523ef733e1153b4">More...</a><br /></td></tr>
<tr class="separator:aa9e6153ad7bd9fa27523ef733e1153b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa93afc398095ff4f1001f11b473c3b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a9aa93afc398095ff4f1001f11b473c3b">hash</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:a9aa93afc398095ff4f1001f11b473c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash value.  <a href="#a9aa93afc398095ff4f1001f11b473c3b">More...</a><br /></td></tr>
<tr class="separator:a9aa93afc398095ff4f1001f11b473c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e01e122b655414c3d8761b2aa2621f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ae5e01e122b655414c3d8761b2aa2621f">nextprime</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:ae5e01e122b655414c3d8761b2aa2621f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute next prime number (binary version).  <a href="#ae5e01e122b655414c3d8761b2aa2621f">More...</a><br /></td></tr>
<tr class="separator:ae5e01e122b655414c3d8761b2aa2621f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34d6f57380154c37497fff229e7c9c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ac34d6f57380154c37497fff229e7c9c4">nextprime</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:ac34d6f57380154c37497fff229e7c9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute next prime number (unary version).  <a href="#ac34d6f57380154c37497fff229e7c9c4">More...</a><br /></td></tr>
<tr class="separator:ac34d6f57380154c37497fff229e7c9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ab29946ca33fa1994892028f664eb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a49ab29946ca33fa1994892028f664eb1">probab_prime_p</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n, int reps=25)</td></tr>
<tr class="memdesc:a49ab29946ca33fa1994892028f664eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test primality.  <a href="#a49ab29946ca33fa1994892028f664eb1">More...</a><br /></td></tr>
<tr class="separator:a49ab29946ca33fa1994892028f664eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54659bd44e96bfdc50e3985c37664af9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a54659bd44e96bfdc50e3985c37664af9">sqrt</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:a54659bd44e96bfdc50e3985c37664af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer square root (binary version).  <a href="#a54659bd44e96bfdc50e3985c37664af9">More...</a><br /></td></tr>
<tr class="separator:a54659bd44e96bfdc50e3985c37664af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53118c88fb159d8e8a8db36fbf440c35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a53118c88fb159d8e8a8db36fbf440c35">sqrt</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:a53118c88fb159d8e8a8db36fbf440c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer square root (unary version).  <a href="#a53118c88fb159d8e8a8db36fbf440c35">More...</a><br /></td></tr>
<tr class="separator:a53118c88fb159d8e8a8db36fbf440c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f9c4a50d6fcfaa4a35a86f4f17df12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ab0f9c4a50d6fcfaa4a35a86f4f17df12">odd_p</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:ab0f9c4a50d6fcfaa4a35a86f4f17df12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if integer is odd.  <a href="#ab0f9c4a50d6fcfaa4a35a86f4f17df12">More...</a><br /></td></tr>
<tr class="separator:ab0f9c4a50d6fcfaa4a35a86f4f17df12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee59b44be34a0071c759e44adea9bdf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#adee59b44be34a0071c759e44adea9bdf">even_p</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:adee59b44be34a0071c759e44adea9bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if integer is even.  <a href="#adee59b44be34a0071c759e44adea9bdf">More...</a><br /></td></tr>
<tr class="separator:adee59b44be34a0071c759e44adea9bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8fcd9090b94b24b6684af97191f7a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#abc8fcd9090b94b24b6684af97191f7a3">fac_ui</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, unsigned long n)</td></tr>
<tr class="memdesc:abc8fcd9090b94b24b6684af97191f7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorial.  <a href="#abc8fcd9090b94b24b6684af97191f7a3">More...</a><br /></td></tr>
<tr class="separator:abc8fcd9090b94b24b6684af97191f7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220b5475ee65174436ac170278371f3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a220b5475ee65174436ac170278371f3e">bin_ui</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n, unsigned long k)</td></tr>
<tr class="memdesc:a220b5475ee65174436ac170278371f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial coefficient (ternary version).  <a href="#a220b5475ee65174436ac170278371f3e">More...</a><br /></td></tr>
<tr class="separator:a220b5475ee65174436ac170278371f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f89d751571bd63d6308f3dfbecdd1c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a0f89d751571bd63d6308f3dfbecdd1c1">bin_ui</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n, unsigned long k)</td></tr>
<tr class="memdesc:a0f89d751571bd63d6308f3dfbecdd1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial coefficient (binary version).  <a href="#a0f89d751571bd63d6308f3dfbecdd1c1">More...</a><br /></td></tr>
<tr class="separator:a0f89d751571bd63d6308f3dfbecdd1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139dd58e56d4cf06d23c25347a2d745d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , binomial_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a139dd58e56d4cf06d23c25347a2d745d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a139dd58e56d4cf06d23c25347a2d745d">binomial</a> (const T &amp;n, const U &amp;k)</td></tr>
<tr class="memdesc:a139dd58e56d4cf06d23c25347a2d745d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic binomial coefficient.  <a href="#a139dd58e56d4cf06d23c25347a2d745d">More...</a><br /></td></tr>
<tr class="separator:a139dd58e56d4cf06d23c25347a2d745d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1954da82f9a2461ecd743a7b6855beb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a1954da82f9a2461ecd743a7b6855beb6">divexact</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;d)</td></tr>
<tr class="memdesc:a1954da82f9a2461ecd743a7b6855beb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact division (ternary version).  <a href="#a1954da82f9a2461ecd743a7b6855beb6">More...</a><br /></td></tr>
<tr class="separator:a1954da82f9a2461ecd743a7b6855beb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ce618674f5c8b843940e9e40cb6bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a50ce618674f5c8b843940e9e40cb6bdd">divexact</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;d)</td></tr>
<tr class="memdesc:a50ce618674f5c8b843940e9e40cb6bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact division (binary version).  <a href="#a50ce618674f5c8b843940e9e40cb6bdd">More...</a><br /></td></tr>
<tr class="separator:a50ce618674f5c8b843940e9e40cb6bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39704db76ff2d6d7a3cafdb178c2af5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a39704db76ff2d6d7a3cafdb178c2af5b">gcd</a> (<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;rop, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op1, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op2)</td></tr>
<tr class="memdesc:a39704db76ff2d6d7a3cafdb178c2af5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GCD (ternary version).  <a href="#a39704db76ff2d6d7a3cafdb178c2af5b">More...</a><br /></td></tr>
<tr class="separator:a39704db76ff2d6d7a3cafdb178c2af5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af939e47f855cb49168e8dc41a5b7c22a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#af939e47f855cb49168e8dc41a5b7c22a">gcd</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op1, const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;op2)</td></tr>
<tr class="memdesc:af939e47f855cb49168e8dc41a5b7c22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">GCD (binary version).  <a href="#af939e47f855cb49168e8dc41a5b7c22a">More...</a><br /></td></tr>
<tr class="separator:af939e47f855cb49168e8dc41a5b7c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac416cef82988fccc1733e08aa9b7fa59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#ac416cef82988fccc1733e08aa9b7fa59">is_zero</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:ac416cef82988fccc1733e08aa9b7fa59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> is zero.  <a href="#ac416cef82988fccc1733e08aa9b7fa59">More...</a><br /></td></tr>
<tr class="separator:ac416cef82988fccc1733e08aa9b7fa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ec487110e6b3455eda43c32c07d086"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a26ec487110e6b3455eda43c32c07d086">is_one</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:a26ec487110e6b3455eda43c32c07d086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> is equal to one.  <a href="#a26ec487110e6b3455eda43c32c07d086">More...</a><br /></td></tr>
<tr class="separator:a26ec487110e6b3455eda43c32c07d086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d230423a3ce5cce628928dd90ab9ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmppp_1_1mp__integer.html#a01d230423a3ce5cce628928dd90ab9ee">is_negative_one</a> (const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> &amp;n)</td></tr>
<tr class="memdesc:a01d230423a3ce5cce628928dd90ab9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> is equal to minus one.  <a href="#a01d230423a3ce5cce628928dd90ab9ee">More...</a><br /></td></tr>
<tr class="separator:a01d230423a3ce5cce628928dd90ab9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;std::size_t SSize&gt;<br />
class mppp::mp_integer&lt; SSize &gt;</h3>

<p>Multiprecision integer class. </p>
<p>This class represent arbitrary-precision signed integers. It acts as a wrapper around the GMP <code>mpz_t</code> type, with a small value optimisation: integers whose size is up to <code>SSize</code> limbs are stored directly in the storage occupied by the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> object, without resorting to dynamic memory allocation. The value of <code>SSize</code> must be at least 1 and less than an implementation-defined upper limit.</p>
<p>When the value of an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> is stored directly within the object, the <em>storage type</em> of the integer is said to be <em>static</em>. When the limb size of the integer exceeds the maximum value <code>SSize</code>, the storage types becomes <em>dynamic</em>. The transition from static to dynamic storage happens transparently whenever the integer value becomes large enough. The demotion from dynamic to static storage usually needs to be requested explicitly. For values of <code>SSize</code> of 1 and 2, optimised implementations of basic arithmetic operations are employed, if supported by the target architecture and if the storage type is static. For larger values of <code>SSize</code>, the <code>mpn_</code> low-level functions of the GMP API are used if the storage type is static. If the storage type is dynamic, the usual <code>mpz_</code> functions from the GMP API are used.</p>
<h1>Interoperable types</h1>
<p>This class has the look and feel of a C++ builtin type: it can interact with most of C++'s integral and floating-point primitive types, and it provides overloaded arithmetic operators. Differently from the builtin types, however, this class does not allow any implicit conversion to/from other types (apart from <code>bool</code>): construction from and conversion to primitive types must always be requested explicitly. As a side effect, syntax such as </p><div class="fragment"><div class="line">mp_integer&lt;1&gt; n = 5;</div><div class="line"><span class="keywordtype">int</span> m = n;</div></div><!-- fragment --><p> will not work, and direct initialization and explicit casting should be used instead: </p><div class="fragment"><div class="line">mp_integer&lt;1&gt; n{5};</div><div class="line"><span class="keywordtype">int</span> m = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(n);</div></div><!-- fragment --><p> The full list of interoperable builtin types is:</p><ul>
<li><code>bool</code>,</li>
<li><code>char</code>, <code>signed char</code> and <code>unsigned char</code>,</li>
<li><code>short</code> and <code>unsigned short</code>,</li>
<li><code>int</code> and <code>unsigned</code>,</li>
<li><code>long</code> and <code>unsigned long</code>,</li>
<li><code>long long</code> and <code>unsigned long long</code>,</li>
<li><code>float</code>, <code>double</code> and <code>long double</code> (<code>long double</code> requires the MPFR library).</li>
</ul>
<h1>API</h1>
<p>Most of the functionality of this class is exposed via inline friend functions, with the general convention that the functions are named after the corresponding GMP functions minus the leading <code>mpz_</code> prefix. For instance, the GMP call </p><div class="fragment"><div class="line">mpz_add(rop,a,b);</div></div><!-- fragment --><p> that writes the result of <code>a+b</code> into <code>rop</code> becomes simply </p><div class="fragment"><div class="line"><a class="code" href="classmppp_1_1mp__integer.html#a5b71854e924730f62da03c77b1eaeae2">add</a>(rop,a,b);</div></div><!-- fragment --><p> where the <a class="el" href="classmppp_1_1mp__integer.html#a5b71854e924730f62da03c77b1eaeae2" title="Ternary add. ">add()</a> function is resolved via argument-dependent lookup. Function calls with overlapping arguments are allowed, unless noted otherwise.</p>
<p>Multiple overloads of the same functionality are often available. Binary functions in GMP are usually implemented via three-arguments functions, in which the first argument is a reference to the return value. The exponentiation function <code>mpz_pow_ui()</code>, for instance, takes three arguments: the return value, the base and the exponent. There are two overloads of the corresponding <a class="el" href="classmppp_1_1mp__integer.html#a3fdda8d1f4c0e3f5986f47411646fe78" title="Ternary exponentiation. ">pow_ui()</a> function:</p><ul>
<li>a ternary overload semantically equivalent to <code>mpz_pow_ui()</code>,</li>
<li>a binary overload taking as inputs the base and the exponent, and returning the result of the exponentiation.</li>
</ul>
<p>This allows to avoid having to set up a return value for one-off invocations of <a class="el" href="classmppp_1_1mp__integer.html#a3fdda8d1f4c0e3f5986f47411646fe78" title="Ternary exponentiation. ">pow_ui()</a> (the binary overload will do it for you). For example: </p><div class="fragment"><div class="line">mp_integer&lt;1&gt; r1, r2, n{3};</div><div class="line"><a class="code" href="classmppp_1_1mp__integer.html#a3fdda8d1f4c0e3f5986f47411646fe78">pow_ui</a>(r1,n,2);   <span class="comment">// Ternary pow_ui(): computes n**2 and stores the result in r1.</span></div><div class="line">r2 = <a class="code" href="classmppp_1_1mp__integer.html#a3fdda8d1f4c0e3f5986f47411646fe78">pow_ui</a>(n,2); <span class="comment">// Binary pow_ui(): returns n**2, which is then assigned to r2.</span></div></div><!-- fragment --><p>In case of unary functions, there are often three overloads available:</p><ul>
<li>a binary overload taking as first parameter a reference to the return value (GMP style),</li>
<li>a unary overload returning the result of the operation,</li>
<li>a nullary member function that modifies the calling object in-place.</li>
</ul>
<p>For instance, here are three possible ways of computing the absolute value: </p><div class="fragment"><div class="line">mp_integer&lt;1&gt; r1, r2, n{-5};</div><div class="line"><a class="code" href="classmppp_1_1mp__integer.html#aefb1bb36658f0142ace086c63f0c1e62">abs</a>(r1,n);   <span class="comment">// Binary abs(): computes and stores the absolute value of n into r1.</span></div><div class="line">r2 = <a class="code" href="classmppp_1_1mp__integer.html#aefb1bb36658f0142ace086c63f0c1e62">abs</a>(n); <span class="comment">// Unary abs(): returns the absolute value of n, which is then assigned to r2.</span></div><div class="line">n.abs();     <span class="comment">// Member function abs(): replaces the value of n with its absolute value.</span></div></div><!-- fragment --><p> Note that at this time only a small subset of the GMP API has been wrapped by <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>.</p>
<h1>Overloaded operators</h1>
<p>This class provides overloaded operators for the basic arithmetic operations, including bit shifting. The binary operators are implemented as inline friend functions, the in-place operators are implemented as member functions. The overloaded operators are resolved via argument-dependent lookup whenever at least one argument is of type <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>, and the other argument is either another <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> or an instance of an interoperable type.</p>
<p>For the common arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>), the type promotion rules are a natural extension of the corresponding rules for native C++ types: if the other argument is a C++ integral, the result will be of type <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>, if the other argument is a C++ floating-point the result will be of the same floating-point type. For example: </p><div class="fragment"><div class="line">mp_integer&lt;1&gt; n1{1}, n2{2};</div><div class="line"><span class="keyword">auto</span> res1 = n1 + n2; <span class="comment">// res1 is an mp_integer</span></div><div class="line"><span class="keyword">auto</span> res2 = n1 * 2; <span class="comment">// res2 is an mp_integer</span></div><div class="line"><span class="keyword">auto</span> res3 = 2 - n2; <span class="comment">// res3 is an mp_integer</span></div><div class="line"><span class="keyword">auto</span> res4 = n1 / 2.f <span class="comment">// res4 is a float</span></div><div class="line"><span class="keyword">auto</span> res5 = 12. / n1 <span class="comment">// res5 is a double</span></div></div><!-- fragment --><p>The modulo operator <code>%</code> accepts only <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> and interoperable integral types as arguments, and it always returns <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> as result. The bit shifting operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> accept only interoperable integral types as shift arguments, and they always return <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> as result.</p>
<p>The relational operators, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code> will promote the arguments to a common type before comparing them. The promotion rules are the same as in the arithmetic operators (that is, both arguments are promoted to <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> if they are both integral types, otherwise they are promoted to the type of the floating-point argument).</p>
<h1>Interfacing with GMP</h1>
<p>This class provides facilities to interface with the GMP library. Specifically, <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> features:</p><ul>
<li>a constructor from the GMP integer type <code>mpz_t</code>,</li>
<li>an <a class="el" href="classmppp_1_1mp__integer.html#a838018dde1f7c7f142a496ae716a53cc" title="Get a pointer to the dynamic storage. ">mp_integer::get_mpz_t()</a> method that promotes <code>this</code> to dynamic storage and returns a pointer to the internal <code>mpz_t</code> instance,</li>
<li>an <code>mpz_view</code> class, an instance of which can be requested via the <a class="el" href="classmppp_1_1mp__integer.html#aaea6b849d829e76086fbeba66fee1337" title="Get an mpz_t view. ">mp_integer::get_mpz_view()</a> method, which allows to use <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> in the GMP API as a drop-in replacement for <code>const mpz_t</code> function arguments.</li>
</ul>
<p>The <code>mpz_view</code> class represent a read-only view of an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> object which is implicitly convertible to the type <code>const mpz_t</code> and which is thus usable as an argument to GMP functions. For example: </p><div class="fragment"><div class="line">mpz_t m;</div><div class="line">mpz_init_set_si(m,1); <span class="comment">// Create an mpz_t with the value 1.</span></div><div class="line">mp_integer&lt;1&gt; n{1}; <span class="comment">// Initialize an mp_integer with the value 1.</span></div><div class="line">mpz_add(m,m,n.get_mpz_view()); <span class="comment">// Compute the result of n + m and store it in m,</span></div><div class="line">                               <span class="comment">// using the GMP API.</span></div></div><!-- fragment --><p> See the documentation of <a class="el" href="classmppp_1_1mp__integer.html#aaea6b849d829e76086fbeba66fee1337" title="Get an mpz_t view. ">mp_integer::get_mpz_view()</a> for more details about the <code>mpz_view</code> class.</p>
<h1>Hashing</h1>
<p>This class provides a <a class="el" href="classmppp_1_1mp__integer.html#a9aa93afc398095ff4f1001f11b473c3b" title="Hash value. ">hash()</a> function to compute a hash value for an integer. A specialisation of the standard <code>std::hash</code> functor is also provided, so that it is possible to use <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> in standard unordered associative containers out of the box. </p>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l00869">869</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7354ac1e0a2a56c3351953219c5a4082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7354ac1e0a2a56c3351953219c5a4082">&#9670;&nbsp;</a></span>mp_integer() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>The default constructor initialises an integer with static storage type and value 0. </p>

</div>
</div>
<a id="a5bbee3a5263b9c01642173d62f8bb196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbee3a5263b9c01642173d62f8bb196">&#9670;&nbsp;</a></span>mp_integer() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The copy constructor deep-copies <code>other</code> into <code>this</code>, preserving the original storage type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object that will be copied into <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9812e5d6af15524570657e36936ef266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9812e5d6af15524570657e36936ef266">&#9670;&nbsp;</a></span>mp_integer() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>The move constructor will leave <code>other</code> in an unspecified but valid state. The storage type of <code>this</code> will be the same as <code>other</code>'s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object that will be moved into <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab3e9601d5fea9d13d6b212af53f6eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3e9601d5fea9d13d6b212af53f6eee">&#9670;&nbsp;</a></span>mp_integer() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , generic_ctor_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic constructor. </p>
<p><b>NOTE:</b> this constructor is enabled only if <code>T</code> is one of the interoperable types.</p>
<p>This constructor will initialize an integer with the value of <code>x</code>. The initialization is always successful if <code>T</code> is an integral type (construction from <code>bool</code> yields 1 for <code>true</code>, 0 for <code>false</code>). If <code>T</code> is a floating-point type, the construction will fail if <code>x</code> is not finite. Construction from a floating-point type yields the truncated counterpart of the input value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value that will be used to initialize <code>this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if <code>x</code> is a non-finite floating-point value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01186">1186</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ac91f598987148a5706fcfc92a4a9fdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91f598987148a5706fcfc92a4a9fdac">&#9670;&nbsp;</a></span>mp_integer() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from C string. </p>
<p>This constructor will initialize <code>this</code> from the null-terminated string <code>s</code>, which must represent an integer value in base <code>base</code>. The expected format is the same as specified by the <code>mpz_set_str()</code> GMP function. <code>base</code> may vary from 2 to 62, or be zero. In the latter case, the base is inferred from the leading characters of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the input string. </td></tr>
    <tr><td class="paramname">base</td><td>the base used in the string representation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the <code>base</code> parameter is invalid or if <code>s</code> is not a valid string representation of an integer in the specified base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://gmplib.org/manual/Assigning-Integers.html">https://gmplib.org/manual/Assigning-Integers.html</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01205">1205</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a4ca61d4876f75f3de21d03d23f652004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca61d4876f75f3de21d03d23f652004">&#9670;&nbsp;</a></span>mp_integer() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from C++ string (equivalent to the constructor from C string). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the input string. </td></tr>
    <tr><td class="paramname">base</td><td>the base used in the string representation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the constructor from C string. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01231">1231</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ade57b8774cb7197cd3350f3f1a434d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade57b8774cb7197cd3350f3f1a434d52">&#9670;&nbsp;</a></span>mp_integer() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::<a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> </td>
          <td>(</td>
          <td class="paramtype">const ::mpz_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from <code>mpz_t</code>. </p>
<p>This constructor will initialize <code>this</code> with the value of the GMP integer <code>n</code>. The storage type of <code>this</code> will be static if <code>n</code> fits in the static storage, otherwise it will be dynamic.</p>
<p><b>NOTE:</b> it is up to the user to ensure that <code>n</code> has been correctly initialized. Calling this constructor with an uninitialized <code>n</code> is undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the input GMP integer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01244">1244</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac1cc8760d544641a0c0eabd4f68e5828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cc8760d544641a0c0eabd4f68e5828">&#9670;&nbsp;</a></span>_get_union() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mppp_impl::integer_union&lt;SSize&gt;&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::_get_union </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the internal union. </p>
<p>This method returns a reference to the union used internally to implement the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> class.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the internal union member. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l05070">5070</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a2f1d93c41ac2b57881a09a39af223e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1d93c41ac2b57881a09a39af223e9b">&#9670;&nbsp;</a></span>_get_union() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const mppp_impl::integer_union&lt;SSize&gt;&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::_get_union </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the internal union. </p>
<p>This method returns a const reference to the union used internally to implement the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> class.</p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the internal union member. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l05080">5080</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="aefb1bb36658f0142ace086c63f0c1e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb1bb36658f0142ace086c63f0c1e62">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::abs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place absolute value. </p>
<p>This method will set <code>this</code> to its absolute value.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04420">4420</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a7a59f7c0ddf4c5939ce7f7249bb3ad90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a59f7c0ddf4c5939ce7f7249bb3ad90">&#9670;&nbsp;</a></span>demote()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::demote </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Demote to static storage. </p>
<p>This method will demote the storage type of <code>this</code> from dynamic to static.</p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the storage type of <code>this</code> is already static and no demotion takes place, or if the current value of <code>this</code> does not fit in static storage, <code>true</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01581">1581</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="aff4c26973a60fdb13ca733e7877b54f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4c26973a60fdb13ca733e7877b54f0">&#9670;&nbsp;</a></span>even_p()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::even_p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if value is even. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>this</code> is even, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04684">4684</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a838018dde1f7c7f142a496ae716a53cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838018dde1f7c7f142a496ae716a53cc">&#9670;&nbsp;</a></span>get_mpz_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_extent&lt;::mpz_t&gt;::type* <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::get_mpz_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the dynamic storage. </p>
<p>This method will first promote <code>this</code> to dynamic storage (if <code>this</code> is not already employing dynamic storage), and it will then return a pointer to the internal <code>mpz_t</code> structure. The returned pointer can be used as an argument for the functions of the GMP API.</p>
<p><b>NOTE:</b> the returned pointer is tied to the lifetime of <code>this</code>. Calling <a class="el" href="classmppp_1_1mp__integer.html#a7a59f7c0ddf4c5939ce7f7249bb3ad90" title="Demote to static storage. ">demote()</a> or assigning an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> with static storage to <code>this</code> will invalidate the returned pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the internal <code>mpz_t</code> structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l05095">5095</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="aaea6b849d829e76086fbeba66fee1337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea6b849d829e76086fbeba66fee1337">&#9670;&nbsp;</a></span>get_mpz_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpz_view <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::get_mpz_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an <code>mpz_t</code> view. </p>
<p>This method will return an object of an unspecified type <code>mpz_view</code> which is implicitly convertible to a const pointer to an <code>mpz_t</code> struct (and which can thus be used as a <code>const mpz_t</code> parameter in GMP functions). In addition to the implicit conversion operator, the <code>const mpz_t</code> object can also be retrieved via the <code>get()</code> method of the <code>mpz_view</code> class. The view provides a read-only GMP-compatible representation of the integer stored in <code>this</code>.</p>
<p><b>NOTE:</b> it is important to keep in mind the following facts about the returned <code>mpz_view</code> object:</p><ul>
<li><code>mpz_view</code> objects are strictly read-only: it is impossible to alter <code>this</code> through an <code>mpz_view</code>, and <code>mpz_view</code> objects can be used in the GMP API only where a <code>const mpz_t</code> parameter is expected;</li>
<li><code>mpz_view</code> objects can only be move-constructed (the other constructors and the assignment operators are disabled);</li>
<li>the returned object and the pointer returned by its <code>get()</code> method might reference internal data belonging to <code>this</code>, and they can thus be used safely only during the lifetime of <code>this</code>;</li>
<li>the lifetime of the pointer returned by the <code>get()</code> method is tied to the lifetime of the <code>mpz_view</code> object (that is, if the <code>mpz_view</code> object is destroyed, any pointer previously returned by <code>get()</code> becomes invalid);</li>
<li>any modification to <code>this</code> will also invalidate the view and the pointer.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>an <code>mpz</code> view of <code>this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01652">1652</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a4291e282795b21b8a36a4dbbf946ae25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4291e282795b21b8a36a4dbbf946ae25">&#9670;&nbsp;</a></span>is_dynamic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::is_dynamic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for dynamic storage. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the storage type is dynamic, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01300">1300</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a2d34786e208468d1e04c24ddd99f880d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d34786e208468d1e04c24ddd99f880d">&#9670;&nbsp;</a></span>is_negative_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::is_negative_one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the value is equal to minus one. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value represented by <code>this</code> is -1, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l05155">5155</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ac214a97cb921eeeedbbe3af0b515b759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac214a97cb921eeeedbbe3af0b515b759">&#9670;&nbsp;</a></span>is_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::is_one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the value is equal to one. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value represented by <code>this</code> is 1, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l05137">5137</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a24a519c1e12c63e885d2f4834d3be68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a519c1e12c63e885d2f4834d3be68f">&#9670;&nbsp;</a></span>is_static()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::is_static </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for static storage. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the storage type is static, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01292">1292</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a7b4bf2290fa0f4da953bc21a41154599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4bf2290fa0f4da953bc21a41154599">&#9670;&nbsp;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::is_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the value is zero. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value represented by <code>this</code> is zero, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l05104">5104</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="acb5524e25c7f364051bb5d3857b1f21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5524e25c7f364051bb5d3857b1f21f">&#9670;&nbsp;</a></span>nbits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::nbits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bits. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bits needed to represent <code>this</code>. If <code>this</code> is zero, zero will be returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01592">1592</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a902f748104522a58f9a41cdc8355dbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902f748104522a58f9a41cdc8355dbe5">&#9670;&nbsp;</a></span>neg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::neg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate in-place. </p>
<p>This method will set <code>this</code> to <code>-this</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01662">1662</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ae75ea34040586a5feb96c5440d2b412b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75ea34040586a5feb96c5440d2b412b">&#9670;&nbsp;</a></span>nextprime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::nextprime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute next prime number (in-place version). </p>
<p>This method will set <code>this</code> to the first prime number greater than the current value.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04531">4531</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ad91c0265fec0a5cc5665d6fa39d7c367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91c0265fec0a5cc5665d6fa39d7c367">&#9670;&nbsp;</a></span>odd_p()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::odd_p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if value is odd. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>this</code> is odd, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04662">4662</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ad7a003134d2ef2312e85131f780c4946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a003134d2ef2312e85131f780c4946">&#9670;&nbsp;</a></span>operator T()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , generic_conversion_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator T </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic conversion operator. </p>
<p><b>NOTE:</b> this operator is enabled only if <code>T</code> is an interoperable type.</p>
<p>This operator will convert <code>this</code> to the type <code>T</code>. Conversion to <code>bool</code> yields <code>false</code> if <code>this</code> is zero, <code>true</code> otherwise. Conversion to other integral types yields the exact result, if representable by the target type <code>T</code>. Conversion to floating-point types might yield inexact values and infinities.</p>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> converted to <code>T</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if <code>T</code> is an integral type and the value of <code>this</code> cannot be represented by <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01550">1550</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="abf98f8995e11f8b8a8a76e71fa33b067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf98f8995e11f8b8a8a76e71fa33b067">&#9670;&nbsp;</a></span>operator%=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , in_place_mod_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place modulo operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>..</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structmppp_1_1zero__division__error.html" title="Exception to signal division by zero. ">zero_division_error</a></td><td>if <code>d</code> is zero. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03510">3510</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a1ee4c146f26a787ac58cb83c988eeaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee4c146f26a787ac58cb83c988eeaa0">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , in_place_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place multiplication operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>the multiplicand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the assignment of a floating-point value to <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>, iff <code>T</code> is a floating-point type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02814">2814</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a0346e69c2267177be4ceee53507cee82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0346e69c2267177be4ceee53507cee82">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identity operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02111">2111</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ab59bace88e3bb525729741722b6dfddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59bace88e3bb525729741722b6dfddb">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefix increment. </p>
<p>Increment <code>this</code> by one.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code> after the increment. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02190">2190</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="af068ad45e35103ddcff3e47f754424fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af068ad45e35103ddcff3e47f754424fc">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suffix increment. </p>
<p>Increment <code>this</code> by one and return a copy of <code>this</code> as it was before the increment.</p>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code> before the increment. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02201">2201</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a08982b7fea3fc3510a01537ba4f7f0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08982b7fea3fc3510a01537ba4f7f0cd">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , in_place_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place addition operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>the addend.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the assignment of a floating-point value to <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>, iff <code>T</code> is a floating-point type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02137">2137</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="afbb22f4a502aba22abd8e80d6e504660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb22f4a502aba22abd8e80d6e504660">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negated copy. </p>
<dl class="section return"><dt>Returns</dt><dd>a negated copy of <code>this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02233">2233</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="aba37db6ac25aea4874b35a15becfc1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba37db6ac25aea4874b35a15becfc1d4">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefix decrement. </p>
<p>Decrement <code>this</code> by one.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code> after the decrement. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02300">2300</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="aedb0c0008d8d2dab7849ae0ec33d222e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb0c0008d8d2dab7849ae0ec33d222e">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suffix decrement. </p>
<p>Decrement <code>this</code> by one and return a copy of <code>this</code> as it was before the decrement.</p>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code> before the decrement. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02314">2314</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="adf948884125604bbe4ecaed039ebdc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf948884125604bbe4ecaed039ebdc4e">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , in_place_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place subtraction operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>the subtrahend.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the assignment of a floating-point value to <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>, iff <code>T</code> is a floating-point type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02261">2261</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="aa0de449356099b21d522383b816deee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0de449356099b21d522383b816deee3">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , in_place_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place division operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>. The result is truncated.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structmppp_1_1zero__division__error.html" title="Exception to signal division by zero. ">zero_division_error</a></td><td>if <code>d</code> is zero and only integral types are involved in the division. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the assignment of a floating-point value to <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>, iff <code>T</code> is a floating-point type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03453">3453</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a6a557db52761f34d11bb26aa7327441e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a557db52761f34d11bb26aa7327441e">&#9670;&nbsp;</a></span>operator<<=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , shift_op_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place left shift operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the bit shift value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if <code>s</code> is negative or larger than an implementation-defined value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03761">3761</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ac166758f51d6d7240624e2e19e47693d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac166758f51d6d7240624e2e19e47693d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>This operator will perform a deep copy of <code>other</code>, preserving its storage type as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>. </dd></dl>

</div>
</div>
<a id="ab554b69f9b90a853bce74bbdc660a28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab554b69f9b90a853bce74bbdc660a28e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>After the move, <code>other</code> will be in an unspecified but valid state, and the storage type of <code>this</code> will be <code>other</code>'s original storage type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>. </dd></dl>

</div>
</div>
<a id="a01310c763f9bb7d333d86d144d0fea8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01310c763f9bb7d333d86d144d0fea8e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , generic_assignment_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic assignment operator. </p>
<p><b>NOTE:</b> this assignment operator is enabled only if <code>T</code> is an interoperable type.</p>
<p>The body of this operator is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> *<span class="keyword">this</span> = <a class="code" href="classmppp_1_1mp__integer.html#a7354ac1e0a2a56c3351953219c5a4082">mp_integer</a>{x};</div></div><!-- fragment --><p> That is, a temporary integer is constructed from <code>x</code> and it is then move-assigned to <code>this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the generic constructor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01284">1284</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a3b5ec57c32b3ca8fe788b496f1c6a2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5ec57c32b3ca8fe788b496f1c6a2f3">&#9670;&nbsp;</a></span>operator>>=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , shift_op_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place right shift operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the bit shift value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if <code>s</code> is negative or larger than an implementation-defined value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03952">3952</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a2ecd20fc837c9fbd7ca991feb95363c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecd20fc837c9fbd7ca991feb95363c5">&#9670;&nbsp;</a></span>probab_prime_p()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::probab_prime_p </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reps</em> = <code>25</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test primality. </p>
<p>This method will run a series of probabilistic tests to determine if <code>this</code> is a prime number. It will return <code>2</code> if <code>this</code> is definitely a prime, <code>1</code> if <code>this</code> is probably a prime and <code>0</code> if <code>this</code> is definitely not-prime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reps</td><td>the number of tests to run.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer indicating if <code>this</code> is a prime.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>reps</code> is less than 1 or if <code>this</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04548">4548</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="af18648a14a792ff12dc508125eff7714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18648a14a792ff12dc508125eff7714">&#9670;&nbsp;</a></span>promote()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::promote </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Promote to dynamic storage. </p>
<p>This method will promote the storage type of <code>this</code> from static to dynamic.</p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the storage type of <code>this</code> is already dynamic and no promotion takes place, <code>true</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01566">1566</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ae7d58df878c6390947e9547c4c26cc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d58df878c6390947e9547c4c26cc31">&#9670;&nbsp;</a></span>sgn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::sgn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if <code>this</code> is zero, 1 if <code>this</code> is positive, -1 if <code>this</code> is negative. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01611">1611</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a6cb5d83fa57cbc9042ec247a8a8ea46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb5d83fa57cbc9042ec247a8a8ea46a">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in limbs. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of limbs needed to represent <code>this</code>. If <code>this</code> is zero, zero will be returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01600">1600</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ad6dd8308e13db9a868396a5cc1f9fbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dd8308e13db9a868396a5cc1f9fbf0">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&amp; <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::sqrt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer square root (in-place version). </p>
<p>This method will set <code>this</code> to its integer square root.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if <code>this</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04626">4626</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a44ff4d52c9d0216801f521870bb921c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ff4d52c9d0216801f521870bb921c0">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmppp_1_1mp__integer.html">mppp::mp_integer</a>&lt; SSize &gt;::to_string </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion to string. </p>
<p>This method will convert <code>this</code> into a string in base <code>base</code> using the GMP function <code>mpz_get_str()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the desired base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>base</code> is smaller than 2 or greater than 62.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://gmplib.org/manual/Converting-Integers.html">https://gmplib.org/manual/Converting-Integers.html</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01350">1350</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a580904fcc3bdca4261460d1355c40875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580904fcc3bdca4261460d1355c40875">&#9670;&nbsp;</a></span>abs <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary absolute value. </p>
<p>This function will set <code>rop</code> to the absolute value of <code>n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">n</td><td>the argument. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04438">4438</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="aa9e6153ad7bd9fa27523ef733e1153b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e6153ad7bd9fa27523ef733e1153b4">&#9670;&nbsp;</a></span>abs <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary absolute value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of <code>n</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04449">4449</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a5b71854e924730f62da03c77b1eaeae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b71854e924730f62da03c77b1eaeae2">&#9670;&nbsp;</a></span>add</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary add. </p>
<p>This function will set <code>rop</code> to <code>op1 + op2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">op1</td><td>the first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>the second argument. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02093">2093</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a00247339df4f51c30cf2abc0c0d4e265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00247339df4f51c30cf2abc0c0d4e265">&#9670;&nbsp;</a></span>add_ui</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add_ui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary add with <code>unsigned long</code>. </p>
<p>This function will set <code>rop</code> to <code>op1 + op2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">op1</td><td>the first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>the second argument. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02492">2492</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="aef60ade1e411f1e5cefe0c3ca86adbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef60ade1e411f1e5cefe0c3ca86adbf7">&#9670;&nbsp;</a></span>addmul</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary multiplyâ€“accumulate. </p>
<p>This function will set <code>rop</code> to <code>rop + op1 * op2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">op1</td><td>the first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>the second argument. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03066">3066</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a220b5475ee65174436ac170278371f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220b5475ee65174436ac170278371f3e">&#9670;&nbsp;</a></span>bin_ui <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bin_ui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial coefficient (ternary version). </p>
<p>This function will set <code>rop</code> to the binomial coefficient of <code>n</code> and <code>k</code>. Negative values of <code>n</code> are supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">n</td><td>the top argument. </td></tr>
    <tr><td class="paramname">k</td><td>the bottom argument. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04735">4735</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a0f89d751571bd63d6308f3dfbecdd1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f89d751571bd63d6308f3dfbecdd1c1">&#9670;&nbsp;</a></span>bin_ui <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> bin_ui </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial coefficient (binary version). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the top argument. </td></tr>
    <tr><td class="paramname">k</td><td>the bottom argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the binomial coefficient of <code>n</code> and <code>k</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04752">4752</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a139dd58e56d4cf06d23c25347a2d745d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139dd58e56d4cf06d23c25347a2d745d">&#9670;&nbsp;</a></span>binomial</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , binomial_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> binomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic binomial coefficient. </p>
<p><b>NOTE:</b> this function is enabled only in the following cases:</p><ul>
<li><code>T</code> and <code>U</code> are both <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>,</li>
<li><code>T</code> is an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> and <code>U</code> is an integral interoperable type for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>,</li>
<li><code>U</code> is an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> and <code>T</code> is an integral interoperable type for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>.</li>
</ul>
<p>This function will compute the binomial coefficient \( {{n}\choose{k}} \), supporting integral input values. The implementation can handle positive and negative values for both the top and the bottom argument. Internally, the <a class="el" href="classmppp_1_1mp__integer.html#a220b5475ee65174436ac170278371f3e" title="Binomial coefficient (ternary version). ">mp_integer::bin_ui()</a> function will be employed.</p>
<p>See <a href="http://arxiv.org/abs/1105.3689/">http://arxiv.org/abs/1105.3689/</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the top argument. </td></tr>
    <tr><td class="paramname">k</td><td>the bottom argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( {{n}\choose{k}} \).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if <code>k</code> is greater than an implementation-defined value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>binomial_impl&lt;T,U&gt;{}(x,y)</code> is a valid expression, returning a type which satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Will return the generalised binomial coefficient: </p><p class="formulaDsp">
\[ {x \choose y}. \]
</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1binomial__impl.html" title="Default functor for the implementation of piranha::math::binomial(). ">piranha::math::binomial_impl</a> functor. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> binomial_impl&lt;T,U&gt;{}(x,y);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>top number. </td></tr>
    <tr><td class="paramname">y</td><td>bottom number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> choose <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1binomial__impl.html" title="Default functor for the implementation of piranha::math::binomial(). ">piranha::math::binomial_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04833">4833</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ad6b64af245a47ede5ed7d8aaf25c2837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b64af245a47ede5ed7d8aaf25c2837">&#9670;&nbsp;</a></span>cmp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison function for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> if <code>op1 == op2</code>, a negative value if <code>op1 &lt; op2</code>, a positive value if <code>op1 &gt; op2</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04140">4140</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a1954da82f9a2461ecd743a7b6855beb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1954da82f9a2461ecd743a7b6855beb6">&#9670;&nbsp;</a></span>divexact <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void divexact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exact division (ternary version). </p>
<p>This function will set <code>rop</code> to the quotient of <code>n</code> and <code>d</code>.</p>
<p><b>NOTE:</b> if <code>d</code> does not divide <code>n</code> exactly, the behaviour will be undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">n</td><td>the dividend. </td></tr>
    <tr><td class="paramname">d</td><td>the divisor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04949">4949</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a50ce618674f5c8b843940e9e40cb6bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ce618674f5c8b843940e9e40cb6bdd">&#9670;&nbsp;</a></span>divexact <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> divexact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exact division (binary version). </p>
<p><b>NOTE:</b> if <code>d</code> does not divide <code>n</code> exactly, the behaviour will be undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the dividend. </td></tr>
    <tr><td class="paramname">d</td><td>the divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quotient of <code>n</code> and <code>d</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04971">4971</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="adee59b44be34a0071c759e44adea9bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee59b44be34a0071c759e44adea9bdf">&#9670;&nbsp;</a></span>even_p</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool even_p </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if integer is even. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>n</code> is even, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04694">4694</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="abc8fcd9090b94b24b6684af97191f7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8fcd9090b94b24b6684af97191f7a3">&#9670;&nbsp;</a></span>fac_ui</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fac_ui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factorial. </p>
<p>This function will set <code>rop</code> to the factorial of <code>n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">n</td><td>the argument for the factorial.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>n</code> is larger than an implementation-defined limit. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04707">4707</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a39704db76ff2d6d7a3cafdb178c2af5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39704db76ff2d6d7a3cafdb178c2af5b">&#9670;&nbsp;</a></span>gcd <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gcd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GCD (ternary version). </p>
<p>This function will set <code>rop</code> to the GCD of <code>op1</code> and <code>op2</code>. The result is always positive. If both operands are zero, zero is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">op1</td><td>the first operand. </td></tr>
    <tr><td class="paramname">op2</td><td>the second operand. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l05038">5038</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="af939e47f855cb49168e8dc41a5b7c22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af939e47f855cb49168e8dc41a5b7c22a">&#9670;&nbsp;</a></span>gcd <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> gcd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GCD (binary version). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>the first operand. </td></tr>
    <tr><td class="paramname">op2</td><td>the second operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the GCD of <code>op1</code> and <code>op2</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l05058">5058</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a9aa93afc398095ff4f1001f11b473c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa93afc398095ff4f1001f11b473c3b">&#9670;&nbsp;</a></span>hash</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash value. </p>
<p>This function will return a hash value for <code>n</code>. The hash value depends only on the value of <code>n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> whose hash value will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a hash value for <code>n</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04463">4463</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a01d230423a3ce5cce628928dd90ab9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d230423a3ce5cce628928dd90ab9ee">&#9670;&nbsp;</a></span>is_negative_one</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_negative_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> is equal to minus one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>n</code> is equal to -1, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l05165">5165</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a26ec487110e6b3455eda43c32c07d086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ec487110e6b3455eda43c32c07d086">&#9670;&nbsp;</a></span>is_one</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> is equal to one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>n</code> is equal to 1, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l05147">5147</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ac416cef82988fccc1733e08aa9b7fa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac416cef82988fccc1733e08aa9b7fa59">&#9670;&nbsp;</a></span>is_zero</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> is zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>n</code> is zero, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l05114">5114</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="acb9a5936e8219c35f795b0011d72032d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9a5936e8219c35f795b0011d72032d">&#9670;&nbsp;</a></span>mul</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary multiplication. </p>
<p>This function will set <code>rop</code> to <code>op1 * op2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">op1</td><td>the first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>the second argument. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02772">2772</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a788d256d0a66f0aefc370c53d6a81a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788d256d0a66f0aefc370c53d6a81a7a">&#9670;&nbsp;</a></span>mul_2exp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mul_2exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::mp_bitcnt_t&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary left shift. </p>
<p>This function will set <code>rop</code> to <code>n</code> multiplied by <code>2**s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">n</td><td>the multiplicand. </td></tr>
    <tr><td class="paramname">s</td><td>the bit shift value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03712">3712</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ac0e3feee7ea6fe09f6bbf55e2b4f004e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e3feee7ea6fe09f6bbf55e2b4f004e">&#9670;&nbsp;</a></span>neg <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void neg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary negation. </p>
<p>This method will set <code>rop</code> to <code>-n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">n</td><td>the integer that will be negated. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01678">1678</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="aa16af02bf463abfad2ecd6eff9e51a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16af02bf463abfad2ecd6eff9e51a87">&#9670;&nbsp;</a></span>neg <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> neg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary negation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the integer that will be negated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>-n</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01689">1689</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ae5e01e122b655414c3d8761b2aa2621f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e01e122b655414c3d8761b2aa2621f">&#9670;&nbsp;</a></span>nextprime <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nextprime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute next prime number (binary version). </p>
<p>This function will set <code>rop</code> to the first prime number greater than <code>n</code>. Note that for negative values of <code>n</code> this function always returns 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">n</td><td>the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> argument. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04508">4508</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ac34d6f57380154c37497fff229e7c9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34d6f57380154c37497fff229e7c9c4">&#9670;&nbsp;</a></span>nextprime <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> nextprime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute next prime number (unary version). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first prime number greater than <code>n</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04519">4519</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ab0f9c4a50d6fcfaa4a35a86f4f17df12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f9c4a50d6fcfaa4a35a86f4f17df12">&#9670;&nbsp;</a></span>odd_p</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool odd_p </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if integer is odd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>n</code> is odd, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04676">4676</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="acff50d5e505ab645606b42f1105edac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff50d5e505ab645606b42f1105edac0">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>op1 != op2</code>, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04177">4177</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a530fbdd0bc604743f5a6024db7d952ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530fbdd0bc604743f5a6024db7d952ea">&#9670;&nbsp;</a></span>operator%</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">common_mod_t&lt;T, U&gt; operator% </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary modulo operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the dividend. </td></tr>
    <tr><td class="paramname">d</td><td>the divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>n % d</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structmppp_1_1zero__division__error.html" title="Exception to signal division by zero. ">zero_division_error</a></td><td>if <code>d</code> is zero. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03497">3497</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a068c436c68c530782a4a2192eb905577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068c436c68c530782a4a2192eb905577">&#9670;&nbsp;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">common_t&lt;T, U&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary multiplication operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>the first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>the second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>op1 * op2</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02800">2800</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a508b02570a977b40b7152c2464312dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508b02570a977b40b7152c2464312dd0">&#9670;&nbsp;</a></span>operator*=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , in_place_lenabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place multiplication for interoperable types. </p>
<p><b>NOTE:</b> this operator is enabled only if <code>T</code> is an interoperable type for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>.</p>
<p>The body of this operator is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> x = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(x * n);</div></div><!-- fragment --><p>That is, the result of the corresponding binary operation is cast back to <code>T</code> and assigned to <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first argument. </td></tr>
    <tr><td class="paramname">n</td><td>the second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the conversion operator of <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02842">2842</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a26cad8b55dd4f168ea18fc13eba7625b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cad8b55dd4f168ea18fc13eba7625b">&#9670;&nbsp;</a></span>operator+</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">common_t&lt;T, U&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary addition operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>the first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>the second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>op1 + op2</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02123">2123</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="af1816b5da4d95b902265b84445d82a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1816b5da4d95b902265b84445d82a77">&#9670;&nbsp;</a></span>operator+=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , in_place_lenabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place addition for interoperable types. </p>
<p><b>NOTE:</b> this operator is enabled only if <code>T</code> is an interoperable type for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>.</p>
<p>The body of this operator is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> x = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(x + n);</div></div><!-- fragment --><p>That is, the result of the corresponding binary operation is cast back to <code>T</code> and assigned to <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first argument. </td></tr>
    <tr><td class="paramname">n</td><td>the second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the conversion operator of <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02176">2176</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a189e6a7960af40d12506db99d7b32f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189e6a7960af40d12506db99d7b32f70">&#9670;&nbsp;</a></span>operator-</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">common_t&lt;T, U&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary subtraction operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>the first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>the second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>op1 - op2</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02247">2247</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ace77778f863c105fea009927ef80a1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace77778f863c105fea009927ef80a1a2">&#9670;&nbsp;</a></span>operator-=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , in_place_lenabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place subtraction for interoperable types. </p>
<p><b>NOTE:</b> this operator is enabled only if <code>T</code> is an interoperable type for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>.</p>
<p>The body of this operator is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> x = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(x - n);</div></div><!-- fragment --><p>That is, the result of the corresponding binary operation is cast back to <code>T</code> and assigned to <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first argument. </td></tr>
    <tr><td class="paramname">n</td><td>the second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the conversion operator of <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02289">2289</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a3d53b543cd48875c58623644935b5fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d53b543cd48875c58623644935b5fea">&#9670;&nbsp;</a></span>operator/</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">common_t&lt;T, U&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary division operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the dividend. </td></tr>
    <tr><td class="paramname">d</td><td>the divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>n / d</code>. The result is truncated if only integral types are involved in the division.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structmppp_1_1zero__division__error.html" title="Exception to signal division by zero. ">zero_division_error</a></td><td>if <code>d</code> is zero and only integral types are involved in the division. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03438">3438</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a4cc8f6ab02edcd3600d5a5f5458cca5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc8f6ab02edcd3600d5a5f5458cca5c">&#9670;&nbsp;</a></span>operator/=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , in_place_lenabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place division for interoperable types. </p>
<p><b>NOTE:</b> this operator is enabled only if <code>T</code> is an interoperable type for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>.</p>
<p>The body of this operator is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> x = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(x / n);</div></div><!-- fragment --><p>That is, the result of the corresponding binary operation is cast back to <code>T</code> and assigned to <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first argument. </td></tr>
    <tr><td class="paramname">n</td><td>the second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the conversion operator of <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> or by <a class="el" href="classmppp_1_1mp__integer.html#a3d53b543cd48875c58623644935b5fea" title="Binary division operator. ">mppp::mp_integer::operator/()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03482">3482</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a3b7ba9c91a38f89cda168194377e1f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7ba9c91a38f89cda168194377e1f3a">&#9670;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>op1 &lt; op2</code>, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04194">4194</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="abd8dcf542bf7e232bdae9bd7ad3d1ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8dcf542bf7e232bdae9bd7ad3d1ce7">&#9670;&nbsp;</a></span>operator<< <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output stream operator for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>. </p>
<p>This operator will print to the stream <code>os</code> the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> <code>n</code> in base 10. Internally it uses the <a class="el" href="classmppp_1_1mp__integer.html#a44ff4d52c9d0216801f521870bb921c0" title="Conversion to string. ">mp_integer::to_string()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the target stream. </td></tr>
    <tr><td class="paramname">n</td><td>the input integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>os</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classmppp_1_1mp__integer.html#a44ff4d52c9d0216801f521870bb921c0" title="Conversion to string. ">mp_integer::to_string()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01316">1316</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a90405a1785f3ed5a08602b1de674a6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90405a1785f3ed5a08602b1de674a6cc">&#9670;&nbsp;</a></span>operator<< <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , shift_op_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left shift operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the multiplicand. </td></tr>
    <tr><td class="paramname">s</td><td>the bit shift value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>n</code> times <code>2**s</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if <code>s</code> is negative or larger than an implementation-defined value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03741">3741</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a9f87804e8d85bfc4cb81744af39ec852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f87804e8d85bfc4cb81744af39ec852">&#9670;&nbsp;</a></span>operator<=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than or equal operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>op1 &lt;= op2</code>, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04245">4245</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ac29e79b650b2c97f2ca569bf4f848812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29e79b650b2c97f2ca569bf4f848812">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>op1 == op2</code>, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04160">4160</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ae55357bd4da2238fd732d5884e9ed2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55357bd4da2238fd732d5884e9ed2ed">&#9670;&nbsp;</a></span>operator></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>op1 &gt; op2</code>, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04228">4228</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a04275962fd456cf9fe5f7bba3c7d5f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04275962fd456cf9fe5f7bba3c7d5f7f">&#9670;&nbsp;</a></span>operator>=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , rel_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than or equal operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>op1 &gt;= op2</code>, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04211">4211</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="aa2aa7c55047cca7dce63938a1f6bf6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2aa7c55047cca7dce63938a1f6bf6d1">&#9670;&nbsp;</a></span>operator>> <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input stream operator for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>. </p>
<p>Equivalent to extracting a line from the stream and then assigning it to <code>n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream. </td></tr>
    <tr><td class="paramname">n</td><td>integer to which the contents of the stream will be assigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>is</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the constructor from string of <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01331">1331</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a98289359023c0c35545bce1e830095a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98289359023c0c35545bce1e830095a3">&#9670;&nbsp;</a></span>operator>> <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , shift_op_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right shift operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the dividend. </td></tr>
    <tr><td class="paramname">s</td><td>the bit shift value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>n</code> divided by <code>2**s</code>. The result will be truncated.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if <code>s</code> is negative or larger than an implementation-defined value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03932">3932</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a000b510b971a4827a6e60e6811952d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000b510b971a4827a6e60e6811952d5e">&#9670;&nbsp;</a></span>pow</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">common_t&lt;T, U&gt; pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic binary exponentiation. </p>
<p><b>NOTE:</b> this function is enabled only if at least one argument is an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> and the other argument is either an <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a> or an interoperable type for <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>.</p>
<p>This function will raise <code>base</code> to the power <code>exp</code>, and return the result. If one of the arguments is a floating-point value, then the result will be computed via <code>std::pow()</code> and it will also be a floating-point value. Otherwise, the result is computed via <a class="el" href="classmppp_1_1mp__integer.html#a3fdda8d1f4c0e3f5986f47411646fe78" title="Ternary exponentiation. ">mppp::mp_integer::pow_ui()</a> and its type is <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mppp::mp_integer</a>. In case of a negative integral exponent and integral base, the result will be zero unless the absolute value of <code>base</code> is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the base. </td></tr>
    <tr><td class="paramname">exp</td><td>the exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>base**exp</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if <code>base</code> and <code>exp</code> are integrals and <code>exp</code> is non-negative and outside the range of <code>unsigned long</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structmppp_1_1zero__division__error.html" title="Exception to signal division by zero. ">zero_division_error</a></td><td>if <code>base</code> and <code>exp</code> are integrals and <code>base</code> is zero and <code>exp</code> is negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if the expression <code>pow_impl&lt;T, U&gt;{}(x, y)</code> is valid, returning a type which satisfies <a class="el" href="structpiranha_1_1is__returnable.html" title="Detect if type can be returned from a function. ">piranha::is_returnable</a>.</dd></dl>
<p>Return <code>x</code> to the power of <code>y</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1pow__impl.html" title="Default functor for the implementation of piranha::math::pow(). ">piranha::math::pow_impl</a> functor's call operator. The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> pow_impl&lt;T, U&gt;{}(x, y);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>base. </td></tr>
    <tr><td class="paramname">y</td><td>exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> to the power of <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1pow__impl.html" title="Default functor for the implementation of piranha::math::pow(). ">piranha::math::pow_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04410">4410</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a3fdda8d1f4c0e3f5986f47411646fe78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdda8d1f4c0e3f5986f47411646fe78">&#9670;&nbsp;</a></span>pow_ui <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pow_ui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary exponentiation. </p>
<p>This function will set <code>rop</code> to <code>base**exp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">base</td><td>the base. </td></tr>
    <tr><td class="paramname">exp</td><td>the exponent. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04258">4258</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="acb43aedb7c011ecd421fc452c3329ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb43aedb7c011ecd421fc452c3329ba3">&#9670;&nbsp;</a></span>pow_ui <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> pow_ui </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary exponentiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the base. </td></tr>
    <tr><td class="paramname">exp</td><td>the exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>base**exp</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04275">4275</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a49ab29946ca33fa1994892028f664eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ab29946ca33fa1994892028f664eb1">&#9670;&nbsp;</a></span>probab_prime_p</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int probab_prime_p </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reps</em> = <code>25</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test primality. </p>
<p>This is the free-function version of <a class="el" href="classmppp_1_1mp__integer.html#a2ecd20fc837c9fbd7ca991feb95363c5" title="Test primality. ">mp_integer::probab_prime_p()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> whose primality will be tested. </td></tr>
    <tr><td class="paramname">reps</td><td>the number of tests to run.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer indicating if <code>this</code> is a prime.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classmppp_1_1mp__integer.html#a2ecd20fc837c9fbd7ca991feb95363c5" title="Test primality. ">mp_integer::probab_prime_p()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04570">4570</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="ad665a1752430eeb5be998576249ee2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad665a1752430eeb5be998576249ee2d4">&#9670;&nbsp;</a></span>sgn</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sgn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> whose sign will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if <code>this</code> is zero, 1 if <code>this</code> is positive, -1 if <code>this</code> is negative. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l01626">1626</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a54659bd44e96bfdc50e3985c37664af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54659bd44e96bfdc50e3985c37664af9">&#9670;&nbsp;</a></span>sqrt <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer square root (binary version). </p>
<p>This method will set <code>rop</code> to the integer square root of <code>n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">n</td><td>the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> whose integer square root will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if <code>n</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04640">4640</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a53118c88fb159d8e8a8db36fbf440c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53118c88fb159d8e8a8db36fbf440c35">&#9670;&nbsp;</a></span>sqrt <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a> sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer square root (unary version). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="classmppp_1_1mp__integer.html" title="Multiprecision integer class. ">mp_integer</a> whose integer square root will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integer square root of <code>n</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if <code>n</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l04652">4652</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a69edb625257e7c83b8def5aed14c91d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69edb625257e7c83b8def5aed14c91d6">&#9670;&nbsp;</a></span>sub</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary subtraction. </p>
<p>This function will set <code>rop</code> to <code>op1 - op2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">op1</td><td>the first argument. </td></tr>
    <tr><td class="paramname">op2</td><td>the second argument. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l02215">2215</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="a0595f2a8d55ed847eb7effd18e73c1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0595f2a8d55ed847eb7effd18e73c1fa">&#9670;&nbsp;</a></span>tdiv_q_2exp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tdiv_q_2exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::mp_bitcnt_t&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary right shift. </p>
<p>This function will set <code>rop</code> to <code>n</code> divided by <code>2**s</code>. <code>rop</code> will be the truncated result of the division.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>the return value. </td></tr>
    <tr><td class="paramname">n</td><td>the dividend. </td></tr>
    <tr><td class="paramname">s</td><td>the bit shift value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03906">3906</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<a id="aa559800b0d25dd89e2c9af9ed4a4f8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa559800b0d25dd89e2c9af9ed4a4f8df">&#9670;&nbsp;</a></span>tdiv_qr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tdiv_qr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmppp_1_1mp__integer.html">mp_integer</a>&lt; SSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary truncated division. </p>
<p>This function will set <code>q</code> to the truncated quotient <code>n / d</code> and <code>r</code> to <code>n % d</code>. The remainder <code>r</code> has the same sign as <code>n</code>. <code>q</code> and <code>r</code> must be two distinct objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the quotient. </td></tr>
    <tr><td class="paramname">r</td><td>the remainder. </td></tr>
    <tr><td class="paramname">n</td><td>the dividend. </td></tr>
    <tr><td class="paramname">d</td><td>the divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>q</code> and <code>r</code> are the same object. </td></tr>
    <tr><td class="paramname"><a class="el" href="structmppp_1_1zero__division__error.html" title="Exception to signal division by zero. ">zero_division_error</a></td><td>if <code>d</code> is zero. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp_09_09_8hpp_source.html#l03405">3405</a> of file <a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="mp_09_09_8hpp_source.html">mp++.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
