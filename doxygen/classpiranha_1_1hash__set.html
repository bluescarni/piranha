<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>piranha: piranha::hash_set&lt; T, Hash, Pred &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpiranha_1_1hash__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">piranha::hash_set&lt; T, Hash, Pred &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Hash set.  
 <a href="classpiranha_1_1hash__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a771b69cb94918ae60f5115f77111d969"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a771b69cb94918ae60f5115f77111d969"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a771b69cb94918ae60f5115f77111d969">hasher</a> = Hash</td></tr>
<tr class="memdesc:a771b69cb94918ae60f5115f77111d969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor type for the calculation of hash values. <br /></td></tr>
<tr class="separator:a771b69cb94918ae60f5115f77111d969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0520d097897953075e6551dccb5bc40d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0520d097897953075e6551dccb5bc40d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a0520d097897953075e6551dccb5bc40d">key_equal</a> = Pred</td></tr>
<tr class="memdesc:a0520d097897953075e6551dccb5bc40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor type for comparing the items in the set. <br /></td></tr>
<tr class="separator:a0520d097897953075e6551dccb5bc40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112f7df82a888381fbad0dff7dedbfd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a112f7df82a888381fbad0dff7dedbfd4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> = T</td></tr>
<tr class="memdesc:a112f7df82a888381fbad0dff7dedbfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type. <br /></td></tr>
<tr class="separator:a112f7df82a888381fbad0dff7dedbfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9616d689ef1d93e4510f70948dd80ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:ae9616d689ef1d93e4510f70948dd80ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type.  <a href="#ae9616d689ef1d93e4510f70948dd80ee">More...</a><br /></td></tr>
<tr class="separator:ae9616d689ef1d93e4510f70948dd80ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed62cf6a42351750dd824d37f117e40"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a> = iterator_impl&lt; <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> const  &gt;</td></tr>
<tr class="memdesc:afed62cf6a42351750dd824d37f117e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type.  <a href="#afed62cf6a42351750dd824d37f117e40">More...</a><br /></td></tr>
<tr class="separator:afed62cf6a42351750dd824d37f117e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5e61c5263b23b29837027bd61a235f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a> = <a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a></td></tr>
<tr class="memdesc:a1d5e61c5263b23b29837027bd61a235f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type.  <a href="#a1d5e61c5263b23b29837027bd61a235f">More...</a><br /></td></tr>
<tr class="separator:a1d5e61c5263b23b29837027bd61a235f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cee89be3acf5257ec5beb0efc9749f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a00cee89be3acf5257ec5beb0efc9749f">local_iterator</a> = typename list::const_iterator</td></tr>
<tr class="memdesc:a00cee89be3acf5257ec5beb0efc9749f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local iterator.  <a href="#a00cee89be3acf5257ec5beb0efc9749f">More...</a><br /></td></tr>
<tr class="separator:a00cee89be3acf5257ec5beb0efc9749f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad89393eef8085dfde8cce757bdea15bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ad89393eef8085dfde8cce757bdea15bb">hash_set</a> (const <a class="el" href="classpiranha_1_1hash__set.html#a771b69cb94918ae60f5115f77111d969">hasher</a> &amp;h=<a class="el" href="classpiranha_1_1hash__set.html#a771b69cb94918ae60f5115f77111d969">hasher</a>{}, const <a class="el" href="classpiranha_1_1hash__set.html#a0520d097897953075e6551dccb5bc40d">key_equal</a> &amp;k=<a class="el" href="classpiranha_1_1hash__set.html#a0520d097897953075e6551dccb5bc40d">key_equal</a>{})</td></tr>
<tr class="memdesc:ad89393eef8085dfde8cce757bdea15bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ad89393eef8085dfde8cce757bdea15bb">More...</a><br /></td></tr>
<tr class="separator:ad89393eef8085dfde8cce757bdea15bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a51cb0135a7ce05b1d2126fd5526c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a09a51cb0135a7ce05b1d2126fd5526c6">hash_set</a> (const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;n_buckets, const <a class="el" href="classpiranha_1_1hash__set.html#a771b69cb94918ae60f5115f77111d969">hasher</a> &amp;h=<a class="el" href="classpiranha_1_1hash__set.html#a771b69cb94918ae60f5115f77111d969">hasher</a>{}, const <a class="el" href="classpiranha_1_1hash__set.html#a0520d097897953075e6551dccb5bc40d">key_equal</a> &amp;k=<a class="el" href="classpiranha_1_1hash__set.html#a0520d097897953075e6551dccb5bc40d">key_equal</a>{}, unsigned n_threads=1u)</td></tr>
<tr class="memdesc:a09a51cb0135a7ce05b1d2126fd5526c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from number of buckets.  <a href="#a09a51cb0135a7ce05b1d2126fd5526c6">More...</a><br /></td></tr>
<tr class="separator:a09a51cb0135a7ce05b1d2126fd5526c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb332b27894abd27db2f96a37fb65424"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#afb332b27894abd27db2f96a37fb65424">hash_set</a> (const <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;other)</td></tr>
<tr class="memdesc:afb332b27894abd27db2f96a37fb65424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#afb332b27894abd27db2f96a37fb65424">More...</a><br /></td></tr>
<tr class="separator:afb332b27894abd27db2f96a37fb65424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ef017f6b6d2e063440dbe46df7e51a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a23ef017f6b6d2e063440dbe46df7e51a">hash_set</a> (<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a23ef017f6b6d2e063440dbe46df7e51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a23ef017f6b6d2e063440dbe46df7e51a">More...</a><br /></td></tr>
<tr class="separator:a23ef017f6b6d2e063440dbe46df7e51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9962971d0ab8e247dc260bffb3eb0b2e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a9962971d0ab8e247dc260bffb3eb0b2e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a9962971d0ab8e247dc260bffb3eb0b2e">hash_set</a> (const InputIterator &amp;<a class="el" href="classpiranha_1_1hash__set.html#a93b2da097fdfd65b08ee15446419d05b">begin</a>, const InputIterator &amp;<a class="el" href="classpiranha_1_1hash__set.html#a74fb4d3e9dba445eeae7dfe6d6993932">end</a>, const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;n_buckets=0u, const hasher &amp;h=hasher{}, const key_equal &amp;k=key_equal{})</td></tr>
<tr class="memdesc:a9962971d0ab8e247dc260bffb3eb0b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from range.  <a href="#a9962971d0ab8e247dc260bffb3eb0b2e">More...</a><br /></td></tr>
<tr class="separator:a9962971d0ab8e247dc260bffb3eb0b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e70936b664aa2f5211cadd7b5c29397"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6e70936b664aa2f5211cadd7b5c29397"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a6e70936b664aa2f5211cadd7b5c29397">hash_set</a> (std::initializer_list&lt; U &gt; list)</td></tr>
<tr class="memdesc:a6e70936b664aa2f5211cadd7b5c29397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from initializer list.  <a href="#a6e70936b664aa2f5211cadd7b5c29397">More...</a><br /></td></tr>
<tr class="separator:a6e70936b664aa2f5211cadd7b5c29397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cccdf7ed4e6a69a2bdd32641b362d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ac0cccdf7ed4e6a69a2bdd32641b362d1">~hash_set</a> ()</td></tr>
<tr class="memdesc:ac0cccdf7ed4e6a69a2bdd32641b362d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ac0cccdf7ed4e6a69a2bdd32641b362d1">More...</a><br /></td></tr>
<tr class="separator:ac0cccdf7ed4e6a69a2bdd32641b362d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3dd442b2ca21a11390d3d4812c0156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#afe3dd442b2ca21a11390d3d4812c0156">operator=</a> (const <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;other)</td></tr>
<tr class="memdesc:afe3dd442b2ca21a11390d3d4812c0156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#afe3dd442b2ca21a11390d3d4812c0156">More...</a><br /></td></tr>
<tr class="separator:afe3dd442b2ca21a11390d3d4812c0156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfdf3a3c36d7bd5556a6ecbe4a015a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#addfdf3a3c36d7bd5556a6ecbe4a015a0">operator=</a> (<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:addfdf3a3c36d7bd5556a6ecbe4a015a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#addfdf3a3c36d7bd5556a6ecbe4a015a0">More...</a><br /></td></tr>
<tr class="separator:addfdf3a3c36d7bd5556a6ecbe4a015a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b2da097fdfd65b08ee15446419d05b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a93b2da097fdfd65b08ee15446419d05b">begin</a> () const </td></tr>
<tr class="memdesc:a93b2da097fdfd65b08ee15446419d05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const begin iterator.  <a href="#a93b2da097fdfd65b08ee15446419d05b">More...</a><br /></td></tr>
<tr class="separator:a93b2da097fdfd65b08ee15446419d05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fb4d3e9dba445eeae7dfe6d6993932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a74fb4d3e9dba445eeae7dfe6d6993932">end</a> () const </td></tr>
<tr class="memdesc:a74fb4d3e9dba445eeae7dfe6d6993932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const end iterator.  <a href="#a74fb4d3e9dba445eeae7dfe6d6993932">More...</a><br /></td></tr>
<tr class="separator:a74fb4d3e9dba445eeae7dfe6d6993932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d843fddaf9f43e904210a4be10ce2f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a2d843fddaf9f43e904210a4be10ce2f4">begin</a> ()</td></tr>
<tr class="memdesc:a2d843fddaf9f43e904210a4be10ce2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator.  <a href="#a2d843fddaf9f43e904210a4be10ce2f4">More...</a><br /></td></tr>
<tr class="separator:a2d843fddaf9f43e904210a4be10ce2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f53ebc55378c1af9f13d45c55757ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad">end</a> ()</td></tr>
<tr class="memdesc:ae9f53ebc55378c1af9f13d45c55757ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator.  <a href="#ae9f53ebc55378c1af9f13d45c55757ad">More...</a><br /></td></tr>
<tr class="separator:ae9f53ebc55378c1af9f13d45c55757ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58a1db344a23f3260fa1b1327ce15f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3">size</a> () const </td></tr>
<tr class="memdesc:aa58a1db344a23f3260fa1b1327ce15f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements contained in the set.  <a href="#aa58a1db344a23f3260fa1b1327ce15f3">More...</a><br /></td></tr>
<tr class="separator:aa58a1db344a23f3260fa1b1327ce15f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04b17946b243676075974f312a733ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ad04b17946b243676075974f312a733ec">empty</a> () const </td></tr>
<tr class="memdesc:ad04b17946b243676075974f312a733ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for empty set.  <a href="#ad04b17946b243676075974f312a733ec">More...</a><br /></td></tr>
<tr class="separator:ad04b17946b243676075974f312a733ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30c6af8e1b498c7ac15c204899e0ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ae30c6af8e1b498c7ac15c204899e0ae9">bucket_count</a> () const </td></tr>
<tr class="memdesc:ae30c6af8e1b498c7ac15c204899e0ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of buckets.  <a href="#ae30c6af8e1b498c7ac15c204899e0ae9">More...</a><br /></td></tr>
<tr class="separator:ae30c6af8e1b498c7ac15c204899e0ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570ae119865b9bdcde64ff10459b3852"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a570ae119865b9bdcde64ff10459b3852">load_factor</a> () const </td></tr>
<tr class="memdesc:a570ae119865b9bdcde64ff10459b3852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load factor.  <a href="#a570ae119865b9bdcde64ff10459b3852">More...</a><br /></td></tr>
<tr class="separator:a570ae119865b9bdcde64ff10459b3852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fc5f5a8ba36f4c50bdd577d0fabe42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a13fc5f5a8ba36f4c50bdd577d0fabe42">bucket</a> (const <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> &amp;k) const </td></tr>
<tr class="memdesc:a13fc5f5a8ba36f4c50bdd577d0fabe42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of destination bucket.  <a href="#a13fc5f5a8ba36f4c50bdd577d0fabe42">More...</a><br /></td></tr>
<tr class="separator:a13fc5f5a8ba36f4c50bdd577d0fabe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455c154b0614dc4d86112550ed3e4346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a455c154b0614dc4d86112550ed3e4346">find</a> (const <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> &amp;k) const </td></tr>
<tr class="memdesc:a455c154b0614dc4d86112550ed3e4346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find element.  <a href="#a455c154b0614dc4d86112550ed3e4346">More...</a><br /></td></tr>
<tr class="separator:a455c154b0614dc4d86112550ed3e4346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb23bf3f6828e339e413a33ad9a3083"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a0eb23bf3f6828e339e413a33ad9a3083">find</a> (const <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> &amp;k)</td></tr>
<tr class="memdesc:a0eb23bf3f6828e339e413a33ad9a3083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find element.  <a href="#a0eb23bf3f6828e339e413a33ad9a3083">More...</a><br /></td></tr>
<tr class="separator:a0eb23bf3f6828e339e413a33ad9a3083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e4e3bff0636960db4be7a2493ed8f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ab6e4e3bff0636960db4be7a2493ed8f7">max_load_factor</a> () const </td></tr>
<tr class="memdesc:ab6e4e3bff0636960db4be7a2493ed8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum load factor.  <a href="#ab6e4e3bff0636960db4be7a2493ed8f7">More...</a><br /></td></tr>
<tr class="separator:ab6e4e3bff0636960db4be7a2493ed8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551aa53c5f51aa1be748d590a7ae777d"><td class="memTemplParams" colspan="2">template&lt;typename U , insert_enabler&lt; U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a551aa53c5f51aa1be748d590a7ae777d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a551aa53c5f51aa1be748d590a7ae777d">insert</a> (U &amp;&amp;k)</td></tr>
<tr class="memdesc:a551aa53c5f51aa1be748d590a7ae777d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element.  <a href="#a551aa53c5f51aa1be748d590a7ae777d">More...</a><br /></td></tr>
<tr class="separator:a551aa53c5f51aa1be748d590a7ae777d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c0ef2f03b797b1f509044a6ec3b80d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a42c0ef2f03b797b1f509044a6ec3b80d">erase</a> (<a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a> it)</td></tr>
<tr class="memdesc:a42c0ef2f03b797b1f509044a6ec3b80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element.  <a href="#a42c0ef2f03b797b1f509044a6ec3b80d">More...</a><br /></td></tr>
<tr class="separator:a42c0ef2f03b797b1f509044a6ec3b80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c574ee8280352852816be2127e3e072"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a6c574ee8280352852816be2127e3e072">clear</a> ()</td></tr>
<tr class="memdesc:a6c574ee8280352852816be2127e3e072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements.  <a href="#a6c574ee8280352852816be2127e3e072">More...</a><br /></td></tr>
<tr class="separator:a6c574ee8280352852816be2127e3e072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf673b10b69a549482652f34834bc80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a4bf673b10b69a549482652f34834bc80">swap</a> (<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;other)</td></tr>
<tr class="memdesc:a4bf673b10b69a549482652f34834bc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap content.  <a href="#a4bf673b10b69a549482652f34834bc80">More...</a><br /></td></tr>
<tr class="separator:a4bf673b10b69a549482652f34834bc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19de666eb17d34c1a97725c04b6238fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a19de666eb17d34c1a97725c04b6238fd">rehash</a> (const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;new_size, unsigned n_threads=1u)</td></tr>
<tr class="memdesc:a19de666eb17d34c1a97725c04b6238fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rehash set.  <a href="#a19de666eb17d34c1a97725c04b6238fd">More...</a><br /></td></tr>
<tr class="separator:a19de666eb17d34c1a97725c04b6238fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947bcba0e0439d1abf15050567034978"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a>, <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a947bcba0e0439d1abf15050567034978">evaluate_sparsity</a> () const </td></tr>
<tr class="memdesc:a947bcba0e0439d1abf15050567034978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information on the sparsity of the set.  <a href="#a947bcba0e0439d1abf15050567034978">More...</a><br /></td></tr>
<tr class="separator:a947bcba0e0439d1abf15050567034978"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Low-level interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7488076a19cba8b11ea501b8ea5632f5"></a>Low-level methods and types. </p>
</td></tr>
<tr class="memitem:a2e2a6bd3afbc8afd369bd45f5efa9b5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a2e2a6bd3afbc8afd369bd45f5efa9b5f">_m_iterator</a> = iterator_impl&lt; <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> &gt;</td></tr>
<tr class="memdesc:a2e2a6bd3afbc8afd369bd45f5efa9b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable iterator.  <a href="#a2e2a6bd3afbc8afd369bd45f5efa9b5f">More...</a><br /></td></tr>
<tr class="separator:a2e2a6bd3afbc8afd369bd45f5efa9b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb51f373c6a699f629cea1a895ec17cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a2e2a6bd3afbc8afd369bd45f5efa9b5f">_m_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#abb51f373c6a699f629cea1a895ec17cd">_m_begin</a> ()</td></tr>
<tr class="memdesc:abb51f373c6a699f629cea1a895ec17cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable begin iterator.  <a href="#abb51f373c6a699f629cea1a895ec17cd">More...</a><br /></td></tr>
<tr class="separator:abb51f373c6a699f629cea1a895ec17cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47fe9d9b519f2cfd56549479b1d000c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a2e2a6bd3afbc8afd369bd45f5efa9b5f">_m_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ae47fe9d9b519f2cfd56549479b1d000c">_m_end</a> ()</td></tr>
<tr class="memdesc:ae47fe9d9b519f2cfd56549479b1d000c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable end iterator.  <a href="#ae47fe9d9b519f2cfd56549479b1d000c">More...</a><br /></td></tr>
<tr class="separator:ae47fe9d9b519f2cfd56549479b1d000c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1752c5aac05d700579558811ae8a9d1c"><td class="memTemplParams" colspan="2">template&lt;typename U , insert_enabler&lt; U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1752c5aac05d700579558811ae8a9d1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a1752c5aac05d700579558811ae8a9d1c">_unique_insert</a> (U &amp;&amp;k, const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;bucket_idx)</td></tr>
<tr class="memdesc:a1752c5aac05d700579558811ae8a9d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert unique element (low-level).  <a href="#a1752c5aac05d700579558811ae8a9d1c">More...</a><br /></td></tr>
<tr class="separator:a1752c5aac05d700579558811ae8a9d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa747b430fe16e4cf93455d89eb715eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#aa747b430fe16e4cf93455d89eb715eb1">_find</a> (const <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> &amp;k, const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;bucket_idx) const </td></tr>
<tr class="memdesc:aa747b430fe16e4cf93455d89eb715eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find element (low-level).  <a href="#aa747b430fe16e4cf93455d89eb715eb1">More...</a><br /></td></tr>
<tr class="separator:aa747b430fe16e4cf93455d89eb715eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3fb5556ef2c91a3d69bb90956b0bd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a6c3fb5556ef2c91a3d69bb90956b0bd2">_bucket_from_hash</a> (const std::size_t &amp;hash) const </td></tr>
<tr class="memdesc:a6c3fb5556ef2c91a3d69bb90956b0bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of destination bucket from hash value.  <a href="#a6c3fb5556ef2c91a3d69bb90956b0bd2">More...</a><br /></td></tr>
<tr class="separator:a6c3fb5556ef2c91a3d69bb90956b0bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8274117bcb42b293702fbe4e2406df09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a8274117bcb42b293702fbe4e2406df09">_bucket</a> (const <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> &amp;k) const </td></tr>
<tr class="memdesc:a8274117bcb42b293702fbe4e2406df09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of destination bucket (low-level).  <a href="#a8274117bcb42b293702fbe4e2406df09">More...</a><br /></td></tr>
<tr class="separator:a8274117bcb42b293702fbe4e2406df09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435316baaf709ace4479a6e5f2db2227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a435316baaf709ace4479a6e5f2db2227">_update_size</a> (const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;new_size)</td></tr>
<tr class="memdesc:a435316baaf709ace4479a6e5f2db2227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force update of the number of elements.  <a href="#a435316baaf709ace4479a6e5f2db2227">More...</a><br /></td></tr>
<tr class="separator:a435316baaf709ace4479a6e5f2db2227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cae073bdb82fa916c9a1e55590cd927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a8cae073bdb82fa916c9a1e55590cd927">_increase_size</a> ()</td></tr>
<tr class="memdesc:a8cae073bdb82fa916c9a1e55590cd927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase bucket count.  <a href="#a8cae073bdb82fa916c9a1e55590cd927">More...</a><br /></td></tr>
<tr class="separator:a8cae073bdb82fa916c9a1e55590cd927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f8ebcae6d7453d73599fe92c37f43b"><td class="memItemLeft" align="right" valign="top">const list &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#af6f8ebcae6d7453d73599fe92c37f43b">_get_bucket_list</a> (const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;idx) const </td></tr>
<tr class="memdesc:af6f8ebcae6d7453d73599fe92c37f43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reference to list in bucket.  <a href="#af6f8ebcae6d7453d73599fe92c37f43b">More...</a><br /></td></tr>
<tr class="separator:af6f8ebcae6d7453d73599fe92c37f43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f392934e0c83ee9b02e353970411d71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a00cee89be3acf5257ec5beb0efc9749f">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a0f392934e0c83ee9b02e353970411d71">_erase</a> (<a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a> it)</td></tr>
<tr class="memdesc:a0f392934e0c83ee9b02e353970411d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element.  <a href="#a0f392934e0c83ee9b02e353970411d71">More...</a><br /></td></tr>
<tr class="separator:a0f392934e0c83ee9b02e353970411d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt;<br />
class piranha::hash_set&lt; T, Hash, Pred &gt;</h3>

<p>Hash set. </p>
<p>Hash set class with interface similar to <code>std::unordered_set</code>. The main points of difference with respect to <code>std::unordered_set</code> are the following:</p>
<ul>
<li>the exception safety guarantee is weaker (see below),</li>
<li>iterators and iterator invalidation: after a rehash operation, all iterators will be invalidated and existing references/pointers to the elements will also be invalid; after an insertion/erase operation, all existing iterators, pointers and references to the elements in the destination bucket will be invalid.</li>
</ul>
<p>The implementation employs a separate chaining strategy consisting of an array of buckets, each one a singly linked list with the first node stored directly within the array (so that the first insertion in a bucket does not require any heap allocation).</p>
<p>An additional set of low-level methods is provided: such methods are suitable for use in high-performance and multi-threaded contexts, and, if misused, could lead to data corruption and other unpredictable errors.</p>
<p>Note that for performance reasons the implementation employs sizes that are powers of two. Hence, particular care should be taken that the hash function does not exhibit commensurabilities with powers of 2.</p>
<h2>Type requirements</h2>
<ul>
<li><code>T</code> must satisfy <a class="el" href="structpiranha_1_1is__container__element.html" title="Type trait for well-behaved container elements. ">piranha::is_container_element</a>,</li>
<li><code>Hash</code> must satisfy <a class="el" href="classpiranha_1_1is__hash__function__object.html" title="Type trait to detect hash function objects. ">piranha::is_hash_function_object</a>,</li>
<li><code>Pred</code> must satisfy <a class="el" href="classpiranha_1_1is__equality__function__object.html" title="Type trait to detect equality function objects. ">piranha::is_equality_function_object</a>.</li>
</ul>
<h2>Exception safety guarantee</h2>
<p>This class provides the strong exception safety guarantee for all operations apart from methods involving insertion, which provide the basic guarantee (after a failed insertion, the set will be left in an unspecified but valid state).</p>
<h2>Move semantics</h2>
<p>Move construction and move assignment will leave the moved-from object equivalent to an empty set whose hasher and equality predicate have been moved-from.</p>
<h2>Serialization</h2>
<p>This class supports serialization if the contained type supports it. Note that the hasher and the comparator are not serialised and they are recreated from scratch upon deserialization.</p>
<dl class="section author"><dt>Author</dt><dd>Francesco Biscani (<a href="#" onclick="location.href='mai'+'lto:'+'blu'+'es'+'car'+'ni'+'@gm'+'ai'+'l.c'+'om'; return false;">blues<span style="display: none;">.nosp@m.</span>carn<span style="display: none;">.nosp@m.</span>i@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a>) </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00109">109</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a2e2a6bd3afbc8afd369bd45f5efa9b5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html#a2e2a6bd3afbc8afd369bd45f5efa9b5f">_m_iterator</a> =  iterator_impl&lt;<a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutable iterator. </p>
<p>This iterator type provides non-const access to the elements of the set. Please note that modifications to an existing element of the set might invalidate the relation between the element and its position in the set. After such modifications of one or more elements, the only valid operation is <a class="el" href="classpiranha_1_1hash__set.html#a6c574ee8280352852816be2127e3e072" title="Remove all elements. ">hash_set::clear()</a> (destruction of the set before calling <a class="el" href="classpiranha_1_1hash__set.html#a6c574ee8280352852816be2127e3e072" title="Remove all elements. ">hash_set::clear()</a> will lead to assertion failures in debug mode). </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01164">1164</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d5e61c5263b23b29837027bd61a235f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a> =  <a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator type. </p>
<p>Equivalent to the iterator type. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00626">626</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afed62cf6a42351750dd824d37f117e40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a> =  iterator_impl&lt;<a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> const&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator type. </p>
<p>A read-only forward iterator. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00617">617</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00cee89be3acf5257ec5beb0efc9749f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html#a00cee89be3acf5257ec5beb0efc9749f">local_iterator</a> =  typename list::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local iterator. </p>
<p>Const iterator that can be used to iterate through a single bucket. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00631">631</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9616d689ef1d93e4510f70948dd80ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size type. </p>
<p>Alias for <code>std::size_t</code>. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00358">358</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad89393eef8085dfde8cce757bdea15bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a771b69cb94918ae60f5115f77111d969">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a771b69cb94918ae60f5115f77111d969">hasher</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a0520d097897953075e6551dccb5bc40d">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a0520d097897953075e6551dccb5bc40d">key_equal</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>If not specified, it will default-initialise the hasher and the equality predicate. The resulting hash set will be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>hasher functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>equality predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructors of <code>Hash</code> or <code>Pred</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00642">642</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09a51cb0135a7ce05b1d2126fd5526c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>n_buckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a771b69cb94918ae60f5115f77111d969">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a771b69cb94918ae60f5115f77111d969">hasher</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a0520d097897953075e6551dccb5bc40d">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a0520d097897953075e6551dccb5bc40d">key_equal</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code>1u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from number of buckets. </p>
<p>Will construct a set whose number of buckets is at least equal to <code>n_buckets</code>. If <code>n_threads</code> is not 1, then the first <code>n_threads</code> threads from <a class="el" href="namespacepiranha.html#af1372bc168006768fa64731fe9f85fb6" title="Alias for piranha::thread_pool_. ">piranha::thread_pool</a> will be used concurrently for the initialisation of the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_buckets</td><td>desired number of buckets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>hasher functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>equality predicate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_threads</td><td>number of threads to use during initialisation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the desired number of buckets is greater than an implementation-defined maximum, or in case of memory errors. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>n_threads</code> is zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the copy constructors of <code>Hash</code> or <code>Pred</code>,</li>
<li><a class="el" href="classpiranha_1_1thread__pool__.html#ace98a230b3be7e60053190ee1abe4fb8" title="Append task. ">piranha::thread_pool::enqueue()</a> or <a class="el" href="classpiranha_1_1future__list.html#a2e80f33417eef5cb4ac2ecf6d7c5c942" title="Move-insert a future. ">piranha::future_list::push_back()</a>, if <code>n_threads</code> is not 1. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00662">662</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb332b27894abd27db2f96a37fb65424"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; T, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The hasher, the equality comparator and the allocator will also be copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td><a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a> that will be copied into <code>this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by memory allocation errors, the copy constructor of the stored type, <code>Hash</code> or <code>Pred</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00676">676</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23ef017f6b6d2e063440dbe46df7e51a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; T, Hash, Pred &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>After the move, <code>other</code> will have zero buckets and zero elements, and its hasher and equality predicate will have been used to move-construct their counterparts in <code>this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>set to be moved. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00716">716</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9962971d0ab8e247dc260bffb3eb0b2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a771b69cb94918ae60f5115f77111d969">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a771b69cb94918ae60f5115f77111d969">hasher</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a0520d097897953075e6551dccb5bc40d">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a0520d097897953075e6551dccb5bc40d">key_equal</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from range. </p>
<p>Create a set with a copy of a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>begin of range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>end of range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_buckets</td><td>number of initial buckets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>hash functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key equality predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the desired number of buckets is greater than an implementation-defined maximum. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructors of <code>Hash</code> or <code>Pred</code>, or arising from calling <a class="el" href="classpiranha_1_1hash__set.html#a551aa53c5f51aa1be748d590a7ae777d" title="Insert element. ">insert()</a> on the elements of the range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00739">739</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e70936b664aa2f5211cadd7b5c29397"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from initializer list. </p>
<p>Will <a class="el" href="classpiranha_1_1hash__set.html#a551aa53c5f51aa1be748d590a7ae777d" title="Insert element. ">insert()</a> all the elements of the initializer list, ignoring the return value of the operation. Hash functor and equality predicate will be default-constructed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>initializer list of elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the desired number of buckets is greater than an implementation-defined maximum. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by either <a class="el" href="classpiranha_1_1hash__set.html#a551aa53c5f51aa1be748d590a7ae777d" title="Insert element. ">insert()</a> or of the default constructor of <code>Hash</code> or <code>Pred</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00759">759</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0cccdf7ed4e6a69a2bdd32641b362d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::~<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>No side effects. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00772">772</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8274117bcb42b293702fbe4e2406df09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_bucket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of destination bucket (low-level). </p>
<p>Equivalent to <a class="el" href="classpiranha_1_1hash__set.html#a13fc5f5a8ba36f4c50bdd577d0fabe42" title="Index of destination bucket. ">bucket()</a>, with the exception that this method will not check if the number of buckets is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>input argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the destination bucket for <code>k</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the hasher. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01282">1282</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c3fb5556ef2c91a3d69bb90956b0bd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_bucket_from_hash </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of destination bucket from hash value. </p>
<p>Note that this method will not check if the number of buckets is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>input hash value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the destination bucket for an object with hash value <code>hash</code>. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01266">1266</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f392934e0c83ee9b02e353970411d71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a00cee89be3acf5257ec5beb0efc9749f">local_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element. </p>
<p>Erase the element to which <code>it</code> points. <code>it</code> must be a valid iterator pointing to an element of the set.</p>
<p>Erasing an element invalidates all iterators pointing to elements in the same bucket as the erased element.</p>
<p>This method will not update the number of elements in the set, nor it will try to access elements outside the bucket to which <code>it</code> refers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>iterator to the element of the set to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local iterator pointing to the element following <code>it</code> prior to the element being erased, or local <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if no such element exists. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01344">1344</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa747b430fe16e4cf93455d89eb715eb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bucket_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find element (low-level). </p>
<p>Locate element in the set. The parameter <code>bucket_idx</code> is the index of the destination bucket for <code>k</code> and, for a set with a nonzero number of buckets, must be equal to the output of <a class="el" href="classpiranha_1_1hash__set.html#a13fc5f5a8ba36f4c50bdd577d0fabe42" title="Index of destination bucket. ">bucket()</a> before the insertion. This method will not check if the value of <code>bucket_idx</code> is correct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>element to be located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucket_idx</td><td>index of the destination bucket for <code>k</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40" title="Iterator type. ">hash_set::iterator</a> to <code>k</code>'s position in the set, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if <code>k</code> is not in the set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by calling the equality predicate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01242">1242</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6f8ebcae6d7453d73599fe92c37f43b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const list&amp; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_get_bucket_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const reference to list in bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>index of the bucket whose list will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the list of items contained in the bucket positioned at index <code>idx</code>. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01323">1323</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8cae073bdb82fa916c9a1e55590cd927"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_increase_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase bucket count. </p>
<p>Increase the number of buckets to the next implementation-defined value.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the operation results in a resize of the set past an implementation-defined maximum number of buckets. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#a19de666eb17d34c1a97725c04b6238fd" title="Rehash set. ">rehash()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01304">1304</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb51f373c6a699f629cea1a895ec17cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a2e2a6bd3afbc8afd369bd45f5efa9b5f">_m_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_m_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutable begin iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#a2e2a6bd3afbc8afd369bd45f5efa9b5f" title="Mutable iterator. ">hash_set::_m_iterator</a> to the beginning of the set. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01169">1169</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae47fe9d9b519f2cfd56549479b1d000c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a2e2a6bd3afbc8afd369bd45f5efa9b5f">_m_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_m_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutable end iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#a2e2a6bd3afbc8afd369bd45f5efa9b5f" title="Mutable iterator. ">hash_set::_m_iterator</a> to the end of the set. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01193">1193</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1752c5aac05d700579558811ae8a9d1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U , insert_enabler&lt; U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_unique_insert </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bucket_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert unique element (low-level). </p>
<dl class="section note"><dt>Note</dt><dd>This template method is activated only if <code>T</code> and <code>U</code> are the same type, aside from cv qualifications and references.</dd></dl>
<p>The parameter <code>bucket_idx</code> is the index of the destination bucket for <code>k</code> and, for a set with a nonzero number of buckets, must be equal to the output of <a class="el" href="classpiranha_1_1hash__set.html#a13fc5f5a8ba36f4c50bdd577d0fabe42" title="Index of destination bucket. ">bucket()</a> before the insertion.</p>
<p>This method will not check if a key equivalent to <code>k</code> already exists in the set, it will not update the number of elements present in the set after the insertion, it will not resize the set in case the maximum load factor is exceeded, nor it will check if the value of <code>bucket_idx</code> is correct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>object that will be inserted into the set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucket_idx</td><td>destination bucket for <code>k</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the newly-inserted element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor of <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4" title="Key type. ">hash_set::key_type</a> or by memory allocation errors. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01220">1220</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a435316baaf709ace4479a6e5f2db2227"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_update_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force update of the number of elements. </p>
<p>After this call, <a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the set. ">size()</a> will return <code>new_size</code> regardless of the true number of elements in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_size</td><td>new set size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01292">1292</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93b2da097fdfd65b08ee15446419d05b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const begin iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f" title="Const iterator type. ">hash_set::const_iterator</a> to the first element of the set, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if the set is empty. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00817">817</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d843fddaf9f43e904210a4be10ce2f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40" title="Iterator type. ">hash_set::iterator</a> to the first element of the set, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if the set is empty. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00849">849</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13fc5f5a8ba36f4c50bdd577d0fabe42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of destination bucket. </p>
<p>Index to which <code>k</code> would belong, were it to be inserted into the set. The index of the destination bucket is the hash value reduced modulo the bucket count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>input argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the destination bucket for <code>k</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1zero__division__error.html" title="Exception for signalling division by zero. ">piranha::zero_division_error</a></td><td>if <a class="el" href="classpiranha_1_1hash__set.html#ae30c6af8e1b498c7ac15c204899e0ae9" title="Number of buckets. ">bucket_count()</a> returns zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#a8274117bcb42b293702fbe4e2406df09" title="Index of destination bucket (low-level). ">_bucket()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00906">906</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae30c6af8e1b498c7ac15c204899e0ae9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of buckets. </p>
<dl class="section return"><dt>Returns</dt><dd>number of buckets in the set. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00881">881</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c574ee8280352852816be2127e3e072"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all elements. </p>
<p>After this call, <a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the set. ">size()</a> and <a class="el" href="classpiranha_1_1hash__set.html#ae30c6af8e1b498c7ac15c204899e0ae9" title="Number of buckets. ">bucket_count()</a> will both return zero. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01059">1059</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad04b17946b243676075974f312a733ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for empty set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the set. ">size()</a> returns 0, <code>false</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00873">873</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74fb4d3e9dba445eeae7dfe6d6993932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const end iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f" title="Const iterator type. ">hash_set::const_iterator</a> to the position past the last element of the set. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00841">841</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9f53ebc55378c1af9f13d45c55757ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40" title="Iterator type. ">hash_set::iterator</a> to the position past the last element of the set. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00857">857</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42c0ef2f03b797b1f509044a6ec3b80d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element. </p>
<p>Erase the element to which <code>it</code> points. <code>it</code> must be a valid iterator pointing to an element of the set.</p>
<p>Erasing an element invalidates all iterators pointing to elements in the same bucket as the erased element.</p>
<p>After the operation has taken place, the <a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the set. ">size()</a> of the set will be decreased by one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>iterator to the element of the set to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the element following <code>it</code> prior to the element being erased, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if no such element exists. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01018">1018</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a947bcba0e0439d1abf15050567034978"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a>,<a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a>&gt; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::evaluate_sparsity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get information on the sparsity of the set. </p>
<dl class="section return"><dt>Returns</dt><dd>an <code>std::map&lt;size_type,size_type&gt;</code> in which the key is the number of elements stored in a bucket and the mapped type the number of buckets containing those many elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by memory errors in standard containers. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01139">1139</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a455c154b0614dc4d86112550ed3e4346"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f">const_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>element to be located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#a1d5e61c5263b23b29837027bd61a235f" title="Const iterator type. ">hash_set::const_iterator</a> to <code>k</code>'s position in the set, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if <code>k</code> is not in the set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#aa747b430fe16e4cf93455d89eb715eb1" title="Find element (low-level). ">_find()</a> or by <a class="el" href="classpiranha_1_1hash__set.html#a8274117bcb42b293702fbe4e2406df09" title="Index of destination bucket (low-level). ">_bucket()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00921">921</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0eb23bf3f6828e339e413a33ad9a3083"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>element to be located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40" title="Iterator type. ">hash_set::iterator</a> to <code>k</code>'s position in the set, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if <code>k</code> is not in the set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#aa747b430fe16e4cf93455d89eb715eb1" title="Find element (low-level). ">_find()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00936">936</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a551aa53c5f51aa1be748d590a7ae777d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U , insert_enabler&lt; U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40">iterator</a>,bool&gt; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert element. </p>
<dl class="section note"><dt>Note</dt><dd>This template method is activated only if <code>T</code> and <code>U</code> are the same type, aside from cv qualifications and references.</dd></dl>
<p>If no other key equivalent to <code>k</code> exists in the set, the insertion is successful and returns the <code>(it,true)</code> pair - where <code>it</code> is the position in the set into which the object has been inserted. Otherwise, the return value will be <code>(it,false)</code> - where <code>it</code> is the position of the existing equivalent object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>object that will be inserted into the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="classpiranha_1_1hash__set.html#afed62cf6a42351750dd824d37f117e40" title="Iterator type. ">hash_set::iterator</a>,bool)</code> pair containing an iterator to the newly-inserted object (or its existing equivalent) and the result of the operation.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1hash__set.html#a112f7df82a888381fbad0dff7dedbfd4" title="Key type. ">hash_set::key_type</a>'s copy constructor,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#aa747b430fe16e4cf93455d89eb715eb1" title="Find element (low-level). ">_find()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a8274117bcb42b293702fbe4e2406df09" title="Index of destination bucket (low-level). ">_bucket()</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">std::overflow_error</td><td>if a successful insertion would result in <a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the set. ">size()</a> exceeding the maximum value representable by type <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee" title="Size type. ">piranha::hash_set::size_type</a>. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if the operation results in a resize of the set past an implementation-defined maximum number of buckets. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00974">974</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a570ae119865b9bdcde64ff10459b3852"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load factor. </p>
<dl class="section return"><dt>Returns</dt><dd><code>(double)<a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the set. ">size()</a> / <a class="el" href="classpiranha_1_1hash__set.html#ae30c6af8e1b498c7ac15c204899e0ae9" title="Number of buckets. ">bucket_count()</a></code>, or 0 if the set is empty. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00889">889</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6e4e3bff0636960db4be7a2493ed8f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum load factor. </p>
<dl class="section return"><dt>Returns</dt><dd>the maximum load factor allowed before a resize. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00944">944</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe3dd442b2ca21a11390d3d4812c0156"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&amp; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; T, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00785">785</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="addfdf3a3c36d7bd5556a6ecbe4a015a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&amp; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; T, Hash, Pred &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>set to be moved into <code>this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00799">799</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19de666eb17d34c1a97725c04b6238fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code>1u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rehash set. </p>
<p>Change the number of buckets in the set to at least <code>new_size</code>. No rehash is performed if rehashing would lead to exceeding the maximum load factor. If <code>n_threads</code> is not 1, then the first <code>n_threads</code> threads from <a class="el" href="namespacepiranha.html#af1372bc168006768fa64731fe9f85fb6" title="Alias for piranha::thread_pool_. ">piranha::thread_pool</a> will be used concurrently during the rehash operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_size</td><td>new desired number of buckets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_threads</td><td>number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>n_threads</code> is zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the constructor from number of buckets, <a class="el" href="classpiranha_1_1hash__set.html#a1752c5aac05d700579558811ae8a9d1c" title="Insert unique element (low-level). ">_unique_insert()</a> or <a class="el" href="classpiranha_1_1hash__set.html#a8274117bcb42b293702fbe4e2406df09" title="Index of destination bucket (low-level). ">_bucket()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01095">1095</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa58a1db344a23f3260fa1b1327ce15f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#ae9616d689ef1d93e4510f70948dd80ee">size_type</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements contained in the set. </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the set. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00865">865</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4bf673b10b69a549482652f34834bc80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; T, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap content. </p>
<p>Will use <code>std::swap</code> to swap hasher and equality predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>swap argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by swapping hasher or equality predicate via <code>std::swap</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01075">1075</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 31 2015 17:25:55 for piranha by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
